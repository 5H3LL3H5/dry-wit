# mod: logging
# api: public
# txt: Logging functions

# set -o xtrace

# fun: LOGGING.getModuleName
# api: public
# txt: Retrieves the name of the module.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the module.
# use: LOGGING.getModuleName; echo "Module: ${RESULT}";
function LOGGING.getModuleName() {
  export RESULT="DW_LOGGING";
  return ${TRUE};
}

# fun: definedTag tag
# api: public
# txt: Checks whether given tag is defined.
# opt: tag: The tag to check.
# txt: 0/TRUE if the tag is defined; 1/FALSE otherwise.
# use: definedTag SUCCESS
function definedTag() {
  local -i _rescode;

  case "${1}" in
    "${SUCCESS}" | "${FAILURE}") _rescode=${TRUE};
                                 ;;
    *) _rescode=${FALSE};
       ;;
  esac

  return ${_rescode};
}

# fun: disableQuietMode
# api: public
# txt: Disables quiet mode.
# txt: Returns 0/TRUE always.
# use: disableQuietMode;
function disableQuietMode() {
  setQuietMode ${FALSE};
}

# fun: enableQuietMode
# api: public
# txt: Enables quiet mode.
# txt: Returns 0/TRUE always.
# use: enableQuietMode;
function enableQuietMode() {
  setQuietMode ${TRUE};
}

# fun: findOutKeyword text
# api: public
# txt: Guesses the type of keyword associated to given text.
# opt: text: The text of the keyword.
# txt: Returns SUCCESS, FAILURE, or UNDEFINED.
# use: findOutKeyword "done";
#      local -i keyword=$?;
function findOutKeyword() {
  local _value="${1}";
  local -i _rescode;

  case "${_value}" in
    "${SUCCESS}") _rescode=${SUCCESS};
                  ;;
    "${FAILURE}") _rescode=${FAILURE};
                  ;;
    *) if isSuccessKeyword "${_value}"; then
         _rescode=${SUCCESS};
       elif isFailureKeyword "${_value}"; then
         _rescode=${FAILURE};
       else
         _rescode=${UNDEFINED};
       fi
       ;;
  esac

  return ${_rescode};
}

# fun: getLogCategory
# api: public
# txt: Retrieves the log category.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log category.
# use: getLogCategory; echo "Log category: ${RESULT}";
function getLogCategory() {
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" LOG_CATEGORY;
}

# fun: getLogCategoryNamespace
# api: public
# txt: Retrieves the log category namespace.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log category namespace.
# use: getLogCategoryNamespace;
#      echo "log category namespace: ${RESULT}"
function getLogCategoryNamespace() {
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" LOG_CATEGORY_NAMESPACE;
}

# fun: isDebugEnabled
# api: public
# txt: Checks whether the debug level is enabled.
# txt: Returns 0/TRUE if debug is allowed; 1/FALSE otherwise.
# use: isDebugEnabled;
function isDebugEnabled() {
  local -i _rescode=${FALSE};

  if isInfoEnabled; then
    LOGGING.getModuleName;
    DW.getGlobalInt "${RESULT}" LOG_DEBUG;
    _rescode=${RESULT};
  fi

  return ${_rescode};
}

# fun: isFailureKeyword
# api: public
# txt: Checks whether given keyword represents a failure.
# opt: keyword: The keyword.
# txt: Returns 0/TRUE if the keyword is considered a failure; 1/FALSE otherwise.
# use: if isFailureKeyword "${keyword}"; then logInfoResult SUCCESS "done"; fi
function isFailureKeyword() {
  local _keyword="${1}";
  local -i _rescode=${FALSE};
  local _i;
  local _oldIFS="${IFS}";
  LOGGING.getModuleName;
  local _moduleName="${RESULT}";

  DW.getGlobalVariableName "${_moduleName}" FAILURE_KEYWORDS;
  local -n _failureKeywords=${RESULT};

  IFS=$' \t\n';
  for _i in ${_failureKeywords[*]}; do
    IFS="${_oldIFS}";
    if    areEqual "${_i}" "${1}" \
        || areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
                    "$(echo \"${_i}\"       | tr [:upper:] [:lower:] 2> /dev/null)"; then
      _rescode=${TRUE};
      break;
    fi;
  done
  IFS="${_oldIFS}";

  if isFalse ${_rescode}; then
    DW.getGlobalVariableName "${_moduleName}" BUILTIN_FAILURE_KEYWORDS;
    local -n _builtinFailureKeywords=${RESULT};

    for _i in ${_builtinFailureKeywords[*]}; do
      IFS="${_oldIFS}";
      if   areEqual "${_i}" "${1}" \
          || areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
                      "$(echo \"${_i}\"       | tr [:upper:] [:lower:] 2> /dev/null)"; then
        _rescode=${TRUE};
        break;
      fi;
    done
    IFS="${_oldIFS}";
  fi

  return ${_rescode};
}

# fun: isInfoEnabled
# api: public
# txt: Checks whether the "info" level is enabled.
# txt: Returns 0/TRUE in such case; 1/FALSE otherwise.
# use: if isInfoEnabled; then ...; fi
function isInfoEnabled() {
  local -i _rescode;

  if isQuietMode; then
    _rescode=${FALSE};
  else
    LOGGING.getModuleName;
    DW.getGlobalInt "${RESULT}" LOG_INFO;
    _rescode=${RESULT};
  fi

  return ${_rescode};
}

# fun: isLowerThanInfoEnabled
# api: public
# txt: Checks whether the enabled log level is lower than "info".
# txt: Returns 0/TRUE in such case; 1/FALSE otherwise.
# use: if isLowerThanInfoEnabled; then ...; fi
function isLowerThanInfoEnabled() {
  if isDebugEnabled || isTraceEnabled; then
    return ${TRUE};
  else
    return ${FALSE};
  fi
}

# fun: isQuietMode
# api: public
# txt: Retrieves whether the quiet mode is on or off.
# txt: Returns 0/TRUE if the mode is enabled; 1/FALSE otherwise.
# use: if isQuietMode; then ...; fi
function isQuietMode() {
  local -i _rescode;

  LOGGING.getModuleName;
  DW.getGlobalInt "${RESULT}" LOG_QUIET;
  _rescode=${RESULT};

  return ${_rescode};
}

# fun: isSuccessKeyword keyword
# api: public
# txt: Checks whether given keyword represents a success.
# opt: keyword: The keyword.
# txt: Returns 0/TRUE if the keyword is considered a success; 1/FALSE otherwise.
# use: if isSuccessKeyword "${keyword}"; then logInfoResult SUCCESS "done"; fi
function isSuccessKeyword() {
  local _keyword="${1}";
  local -i _rescode=${FALSE};
  local _i;
  local _oldIFS="${IFS}";
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" SUCCESS_KEYWORDS;
  local -n _successKeywords="${RESULT}";

  IFS=$' \t\n';
  if    isNotEmpty "${_successKeywords}" \
      && isNotEmpty ${_successKeywords[*]}; then
    for _i in ${_successKeywords[*]}; do
      IFS="${_oldIFS}";
      if    areEqual "${_i}" "${_keyword}" \
          || areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
                      "$(echo \"${_i}\"       | tr [:upper:] [:lower:] 2> /dev/null)"; then
        _rescode=${TRUE};
        break;
      fi;
    done
    IFS="${_oldIFS}";
  fi

  if isFalse ${_rescode}; then
    for _i in ${BUILTIN_SUCCESS_KEYWORDS[*]}; do
      IFS="${_oldIFS}";
      if    areEqual "${_i}" "${1}" \
          || areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
                      "$(echo \"${_i}\"       | tr [:upper:] [:lower:] 2> /dev/null)"; then
        _rescode=${TRUE};
        break;
      fi;
    done
    IFS="${_oldIFS}";
  fi

  return ${_rescode};
}

# fun: isTraceEnabled
# api: public
# txt: Checks whether trace is enabled.
# txt: Returns 0/TRUE if trace is enabled; 1/FALSE otherwise.
# use: isTraceEnabled;
function isTraceEnabled() {
  local -i _rescode=${FALSE};

  if isDebugEnabled; then
    LOGGING.getModuleName;
    DW.getGlobalInt "${RESULT}" LOG_TRACE;
    _rescode=${RESULT};
  fi

  return ${_rescode};
}

# fun: log message
# api: public
# txt: Logs a message as "info".
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: log "Operation in progress";
function log() {
  checkNotEmpty "message" "${1}" 1;
  _logInfo "$@";
}

# fun: logDebug message
# api: public
# txt: Logs given message under the "debug" level.
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: logDebug "Operation in progress";
function logDebug() {
  if isDebugEnabled; then
    checkNotEmpty "message" "${1}" 1;
    LOGGING.logStuff DEBUG "$@";
  fi
}

# fun: logDebugFile file
# api: public
# txt: Logs the contents of given file, under the "debug" level.
# opt: file: The file to log.
# txt: Returns 0/TRUE always.
# use: logDebugFile '/tmp/my-log.txt';
function logDebugFile() {
  if isDebugEnabled; then
    checkNotEmpty "file" "${1}" 1;
    cat "${1}" | while IFS='' read -r line; do LOGGING.logStuff DEBUG "${line}"; done
  fi
}

# fun: logDebugFileContents file
# api: public
# txt: Logs the contents of a file, using the DEBUG level.
# opt: file: The file.
# txt: Returns 0/TRUE always.
# use: logDebugFileContents /tmp/my-file.log
function logDebugFileContents() {
  if isDebugEnabled; then
    [ -f "$1" ] && sed 's ^\s+$  g' "$1" | awk '{printf("logDebug \"%s\"\n", $0);}' | sh
  fi
}

# fun: logDebugResult SUCCESS|FAILURE message
# api: public
# txt: Logs given outcome under the "debug" level.
# opt: SUCCESS|FAILURE: The keyword.
# opt: message: The outcome to log.
# txt: Returns 0/TRUE always.
# use: logDebugResult SUCCESS "done";
function logDebugResult() {
  local _outcome="${1}";
  shift;
  local _message="${@}";

  if isDebugEnabled; then
    checkNotEmpty "outcome" "${_outcome}" 1;
    checkNotEmpty "message" "${_message}" 2;
    LOGGING.logStuffResult DEBUG "${_outcome}" "${_message}";
  fi
}

# fun: logFile file
# api: public
# txt: Logs the contents of a file, as "info".
# opt: file: The file with the log messages.
# txt: Returns 0/TRUE always.
# use: logFile /tmp/my-log.txt;
function logFile() {
  checkNotEmpty "file" "${1}" 1;
  cat "${1}" | while IFS='' read -r line; do LOGGING.logStuff INFO "${line}"; done
}

# fun: LOGGING.alignRight message outcome
# api: private
# txt: Writes spaces until the next message to print is aligned to the right.
# opt: message: The log-line message.
# opt: outcome: The log outcome message.
# txt: Returns 0/TRUE always.
# use: LOGGING.alignRight "Finishing work" "done";
function LOGGING.alignRight() {
  local _logLineMessage="${1}";
  checkNotEmpty "message" "${_logLineMessage}" 1;

  local _outcome="${2}";
  checkNotEmpty "outcome" "${_outcome}" 2;

  local _logMessage;

  local -i _termWidth;
  local -i _index;
  local -i _offset=0;
  local -i _end;
  local _allowsColors;
  local _token;

  LOGGING.retrieveLogOutcomeTokens "${_outcome}";
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _token in "${_DRY_WIT_LOG_OUTCOME_TOKENS[@]}"; do
    _logMessage="${_logMessage}${_token}";
  done
  IFS="${_oldIFS}";

  getTermWidth;
  if isTrue $?; then
    _termWidth=${RESULT};
    if [ ${_termWidth} -le 0 ]; then
      exitWithErrorCode POSTCONDITION_NOT_SATISFIED "getTermWidth() must not return successfully providing 0 as output";
    fi
    _index=0;
    allowsColors;
    _allowsColors=$?;
    if isTrue ${_allowsColors}; then
      _offset=$((_offset));
    fi
    _end=$((${_offset}+${_termWidth}-${#_logLineMessage}%${_termWidth}-${#_logMessage}-1));
    while [ $((_end)) -lt 0 ]; do
      echo "";
      _end=$((-${_end}+${_offset}+${_termWidth}-${#_logMessage}));
    done
    while [ $((${_end}-${_index}+1)) != 0 ]; do
      _index=$((${_index}+1));
      echo -n "${LOG_OUTCOME_SEPARATOR}";
    done
  fi
}

# fun: LOGGING.closeLogLine
# api: private
# txt: Closes the log line.
# txt: Returns 0/TRUE always.
# use: LOGGING.closeLogLine;
function LOGGING.closeLogLine() {
  LOGGING.getModuleName;
  DW.setGlobalInt "${RESULT}" LOG_LINE_OPEN ${FALSE};
}

# fun: LOGGING.echoColorAwareLogPrefix category TRUE|FALSE level
# api: private
# txt: Prints the log prefix, for color terminals.
# opt: category: The log category.
# opt: TRUE|FALSE: ${TRUE} if using colors; ${FALSE} otherwise.
# opt: level: The log level.
# txt: Returns 0/TRUE always.
# use: LOGGING.echoColorAwareLogPrefix "cat" ${TRUE} DEBUG
function LOGGING.echoColorAwareLogPrefix() {
  local _category="${1}";
  checkNotEmpty category "${_category}" 1;

  local -i _allowsColors=${2};
  checkNotEmpty allowsColors "${_allowsColors}" 2;

  local _level="${3}";
  checkNotEmpty level "${_level}" 3;

  local _aux;
  local _colors;
  local -i _i=0;
  LOGGING.getModuleName;
  local _moduleName="${RESULT}";

  LOGGING.retrieveLogPrefixTokens "${_category}" "${_level}";

  DW.getGlobalVariableName "${_moduleName}" LOG_PREFIX_TOKENS;
  local -n _logPrefixTokens="${RESULT}";

  DW.getGlobalVariableName "${_moduleName}" LOG_PREFIX_COLORS;
  local -n _logPrefixColors="${RESULT}";

  local _oldIFS="${IFS}";
  IFS=$'\t\n';
  _i=0;
  for _aux in ${_logPrefixTokens[@]}; do
    IFS="${_oldIFS}";
    if isTrue ${_allowsColors}; then
      echoInColor -n "${_logPrefixColors[${_i}]}" "${_aux}";
    else
      echo -n "${_logPrefixTokens[${_i}]}";
    fi
    _i=$((_i+1));
  done
  IFS="${_oldIFS}";

  if isTrue ${_allowsColors}; then
    resetColor;
  fi
  echo -n " ";
}

# fun: LOGGING.echoLogOutcome level SUCCESS|FAILURE|IN_PROGRESS text
# api: private
# txt: Prints the log outcome.
# opt: level: The log level.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The keyword  (SUCCESS, FAILURE, IN_PROGRESS).
# opt: text: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.echoLogOutcome DEBUG SUCCESS "sample"
function LOGGING.echoLogOutcome() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift;

  local _text="${@}";
  local -i _len;
  local -i _allowsColors;
  local _colors;
  local _inProgressMessage;
  local _logPrefix;
  local -i _i;

  LOGGING.retrieveLogOutcomeTokens "${_text}";

  allowsColors;
  _allowsColors=$?;

  if isTrue ${_allowsColors}; then
    LOGGING.retrieveLogOutcomeColors ${_keyword};
  fi

  LOGGING.peekLog;
  _inProgressMessage="${RESULT}";
  LOGGING.peekLogCategory;
  _category="${RESULT}";
  if isEmpty "${_category}"; then
    exitWithErrorCode POSTCONDITION_NOT_SATISFIED "_peekLogCaterory must not return an empty string";
  fi
  LOGGING.peekLogLevel;
  _level="${RESULT}";
  LOGGING.retrieveLogPrefix "${_category}" "${_level}";
  _logPrefix="${RESULT}";
  LOGGING.alignRight "${_logPrefix}${_inProgressMessage}" "${_text}";

  LOGGING.getModuleName;
  local _moduleName="${RESULT}";
  DW.getGlobalVariableName "${_moduleName}" LOG_OUTCOME_TOKENS;
  local -n _logOutcomeTokens=${RESULT};

  DW.getGlobalVariableName "${_moduleName}" LOG_OUTCOME_COLORS;
  local -n _logOutcomeColors=${RESULT};

  _len=$((${#_logOutcomeTokens[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    IFS="${_oldIFS}";
    if isTrue ${_allowsColors}; then
      echoInColor -n "${_logOutcomeColors[${_i}]}" "${_logOutcomeTokens[${_i}]}";
    else
      echo -n "${_logOutcomeTokens[${_i}]}";
    fi
  done
  IFS="${_oldIFS}";

  if isTrue ${_allowsColors}; then
    resetColor;
  fi
}

# fun: LOGGING.echoLogOutcomeNested level SUCCESS|FAILURE|IN_PROGRESS text
# api: private
# txt: Prints the log outcome, used when nesting log calls.
# opt: level: The log level.
# opt: SUCCESS_FAILURE_IN_PROGRESS: The keyword  (SUCCESS, FAILURE, IN_PROGRESS).
# opt: text: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.echoLogOutcome DEBUG SUCCESS "sample"
function LOGGING.echoLogOutcomeNested() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift;

  local _text="${@}";
  local _inProgressMessage;
  local _alreadyInProgressMessage;
  local _category;
  local _alreadyInProgressCategory;
  local _indentation;
  local -i _i;
  LOGGING.popLog;
  _inProgressMessage="${RESULT}";
  LOGGING.popLogCategory;
  _category="${RESULT}";
  LOGGING.echoLogOutcome "${_level}" "${_keyword}" "${_text}";
  LOGGING.numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_NESTED_INDENTATION;
  local -n _logNestedIndentation=${RESULT};

  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 1 ${_nestedTasks}); do
    IFS="${_oldIFS}";
    _indentation="${_indentation}${_logNestedIndentation}";
  done
  IFS="${_oldIFS}";

  LOGGING.pushLog "${_indentation}${_inProgressMessage}";
  LOGGING.pushLogCategory "${_category}";
}

# fun: LOGGING.echoLogPrefix category level
# api: private
# txt: Prints the log prefix.
# opt: category: The log category.
# opt: level: The log level.
# txt: Returns 0/TRUE always.
# use: LOGGING.echoLogPrefix "cat" DEBUG;
function LOGGING.echoLogPrefix() {
  local _category="${1}";
  checkNotEmpty "category" "${_category}" 1;

  local _level="${2}";
  checkNotEmpty "level" "${_level}" 2;

  local _allowsColors;
  allowsColors;
  _allowsColors=$?;
  LOGGING.echoColorAwareLogPrefix "${_category}" ${_allowsColors} "${_level}";
}

# fun: LOGGING.getLastLog
# api: private
# txt: Retrieves the last log message.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the last log message.
# use: LOGGING.getLastLog; echo "Last log: ${RESULT}";
function LOGGING.getLastLog() {
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" LAST_LOG;
}

# fun: isLogLineOpen
# api: public
# txt: Checks whether the log line is currently opened.
# txt: Returns 0/TRUE if it's open; 1/FALSE otherwise.
# use: if isLogLineOpen; then ...; fi
function isLogLineOpen() {
  LOGGING.getModuleName;
  DW.getGlobalInt "${RESULT}" LOG_LINE_OPEN;
  return ${RESULT};
}

# fun: LOGGING.logCompleted level SUCCESS|FAILURE|IN_PROGRESS outcome
# api: private
# txt: Prints the result of a task.
# opt: level: The log level.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS).
# opt: outcome: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.logCompleted INFO SUCCESS "done";
function LOGGING.logCompleted() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift;
  local _text="${@}";
  checkNotEmpty "text" "${_text}" 3;

  local -i nestedTasks;

  LOGGING.setLastLogLevel "${_level}";
  LOGGING.numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if [ ${_nestedTasks} -gt 1 ]; then
    LOGGING.logCompletedNested "${_level}" "${_keyword}" "${_text}";
  else
    LOGGING.logCompletedNoNested "${_level}" "${_keyword}" "${_text}";
  fi
}

# fun: LOGGING.logCompletedNested level SUCCESS|FAILURE|IN_PROGRESS outcome
# api: private
# txt: Prints the result of a task, when there're nested tasks.
# opt: level: The log level.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS).
# opt: outcome: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.logCompletedNested INFO SUCCESS "done";
function LOGGING.logCompletedNested() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift

  local _message="$@";
  checkNotEmpty "outcome" "${_message}" 3;

  local _nestedTask;
  local _nestedTaskCategory;
  local _logPrefix;
  LOGGING.echoLogOutcome "${_level}" "${_keyword}" "${_message}";
  echo;
  LOGGING.popLogCategory;
  LOGGING.peekLogCategory;
  _nestedTaskCategory="${RESULT}";
  LOGGING.popLogLevel;
  LOGGING.peekLogLevel;
  _nestedTaskLevel="${RESULT}";
  LOGGING.popLog;
  LOGGING.peekLog;
  _nestedTask="${RESULT}";
  LOGGING.echoLogPrefix "${_nestedTaskCategory}" "${_nestedTaskLevel}";
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" DEFAULT_LOG_RESUMING_TASK_COLOR;
  local _defaultLogResumingTaskColor="${RESULT}";
  LOGGING.setLastLogLevel "${_level}";
  echoColorizedText "${_nestedTask}" "" "${_defaultLogResumingTaskColor}";
}

# fun: LOGGING.logCompletedNestedNoPop level SUCCESS|FAILURE|IN_PROGRESS outcome
# api: private
# txt: Prints the result of a task, when there're nested tasks.
# opt: level: The log level.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS);
# opt: outcome: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.logCompletedNested SUCCESS "done";
function LOGGING.logCompletedNestedNoPop() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift
  local _message="$@";
  checkNotEmpty "message" "${_message}" 3;

  LOGGING.echoLogOutcomeNested "${_level}" "${_keyword}" "${_message}";
}

# fun: LOGGING.logCompletedNoNested level SUCCESS|FAILURE|IN_PROGRESS outcome
# api: private
# txt: Prints the result of a task.
# opt: level: The log level.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS).
# opt: outcome: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.logCompletedNoNested INFO SUCCESS "done";
function LOGGING.logCompletedNoNested() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift;

  local _text="${@}";
  checkNotEmpty "outcome" "${_text}" 3;

  LOGGING.echoLogOutcome "${_level}" "${_keyword}" "${_text}";
  LOGGING.popLog;
  LOGGING.popLogCategory;
  LOGGING.popLogLevel;
  echo;
}

# fun: LOGGING.logInProgress level message
# api: private
# txt: Prints a log message, indicating some uncompleted task.
# opt: level: The log level.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: LOGGING.logInProgress INFO "Calculating ...";
function LOGGING.logInProgress() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _message="$@";
  checkNotEmpty "message" "${_message}" 2;

  local -i nestedTasks;
  local _category;
  LOGGING.retrieveLogNamespace;
  _category="${RESULT}";

  LOGGING.setLastLogLevel "${_level}";
  LOGGING.numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if [ ${_nestedTasks} -gt 0 ]; then
    LOGGING.logInProgressNested "${_category}" "${_level}" "${_message}";
  else
    LOGGING.logInProgressNoNested "${_category}" "${_level}" "${_message}";
  fi
}

# fun: LOGGING.logInProgressNested category level message
# api: private
# txt: Prints a log message, indicating some uncompleted task, when there're nested tasks.
# opt: category: The category.
# opt: level: The log level.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: LOGGING.logInProgressNested "cat" DEBUG "Calculating ...";
function LOGGING.logInProgressNested() {
  local _category="${1}";
  checkNotEmpty category "${_category}" 1;
  shift;

  local _level="${1}";
  checkNotEmpty level "${_level}" 2;
  shift;

  local _message="$@";
  checkNotEmpty message "${_message}" 3;

  local _logPrefix;
  LOGGING.pushLog "${_message}";
  LOGGING.pushLogCategory "${_category}";
  LOGGING.pushLogLevel "${_level}";
  LOGGING.getModuleName;
  local _moduleName="${RESULT}";
  DW.getGlobalString "${_moduleName}" NESTED_TASK_IN_PROGRESS;
  local _nestedTaskInProgress="${RESULT}";
  LOGGING.logCompletedNestedNoPop "${_level}" IN_PROGRESS "${_nestedTaskInProgress}";
  echo;

  LOGGING.retrieveLogPrefix "${_category}" "${_level}";
  _logPrefix="${RESULT}";
  LOGGING.echoLogPrefix "${_category}" "${_level}";
  LOGGING.peekLog;
  _actualMessage="${RESULT}";
  DW.getGlobalString "${_moduleName}" DEFAULT_LOG_PREFIX_COLOR;
  local _defaultLogPrefixColor="${RESULT}";
  LOGGING.setLastLogLevel "${_level}";
  echoColorizedText "${_actualMessage}" "" "${_defaultLogPrefixColor}";
}

# fun: LOGGING.logInProgressNoNested
# api: private
# txt: Prints a log message, indicating some uncompleted task, when there're no nested tasks.
# opt: category: The log category.
# opt: level: The log level.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: LOGGING.logProgressNoNested "cat" INFO "Calculating ...";
function LOGGING.logInProgressNoNested() {
  local _category="${1}";
  checkNotEmpty category "${_category}" 1;
  shift;

  local _level="${1}";
  checkNotEmpty level "${_level}" 2;
  shift;

  local _message="$@";
  checkNotEmpty message "${_message}" 3;
  local _logPrefix;

  _logPrefix="${RESULT}";
  LOGGING.pushLogCategory "${_category}";
  LOGGING.pushLog "${_message}";
  LOGGING.pushLogLevel "${_level}";
  LOGGING.echoLogPrefix "${_category}" "${_level}";
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" DEFAULT_LOG_PREFIX_COLOR;
  local _defaultLogPrefixColor="${RESULT}";
  LOGGING.setLastLogLevel "${_level}";
  echoColorizedText "${_message}" "" "${_defaultLogPrefixColor}";
}

# fun: LOGGING.logMessage
# api: private
# txt: Prints a log message.
# opt: level: The log level.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: LOGGING.logMessage INFO "A message to log";
function LOGGING.logMessage() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;

  shift;
  local _message="$@";
  checkNotEmpty "message" "${_message}" 2;
  LOGGING.logInProgress "${_level}" "${_message}";
  echo;
}

# fun: LOGGING.logStuff
# api: private
# txt: Main logging logic.
# opt: level: The logging level.
# opt: -n: Whether to use a new line character at the end or not.
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: LOGGING.logStuff INFO -n "Operation in progress";
function LOGGING.logStuff() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;
  local _minusN="${1}";
  if [ "-n" == "${_minusN}" ]; then
    shift;
  fi
  LOGGING.setLastLogLevel "${_level}";
  LOGGING.logInProgress "${_level}" "$@";
  if [ "-n" != "${_minusN}" ]; then
    echo;
    LOGGING.popLog;
    LOGGING.popLogCategory;
  fi
}

# fun: LOGGING.setLastLogLevel level
# api: private
# txt: Annotates the level of the last logged message.
# opt: level: The log level.
# txt: Returns 0/TRUE always.
# use: LOGGING.setLastLogLevel INFO;
function LOGGING.setLastLogLevel() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  LOGGING.getModuleName;
  DW.setGlobalString "${RESULT}" LAST_LOG_LEVEL "${_level}";
}

# fun: getLastLogLevel
# txt: Retrieves the level of the last logged message.
# txt: Returns 0/TRUE always.
# txt: RESULT contains the log level.
# use: getLastLogLevel; echo "Last log level: ${RESULT}";
function getLastLogLevel() {
  local _result;
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" LAST_LOG_LEVEL;
  _result="${RESULT}";
  if isEmpty "${_result}"; then
    LOGGING.peekLogLevel;
  fi
}

# fun: LOGGING.logStuffResult
# api: private
# txt: Logs the outcome of an operation.
# opt: level: The log level.
# opt: SUCCESS|FAILURE: The outcome.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: LOGGING.logStuffResult INFO SUCCESS "done";
function LOGGING.logStuffResult() {
  local _level="${1}";
  local _outcome="${2}";

  checkNotEmpty "level" "${_level}" 1;
  shift;

  checkNotEmpty "outcome" "${_outcome}" 2;
  shift;

  checkNotEmpty "text" "${@}" 3;

  local -i _nestedTasks;
  LOGGING.numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if isZero ${_nestedTasks}; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "No ongoing process to print the outcome for. Review ${FUNCNAME[2]}";
  fi
  LOGGING.logCompleted "${_level}" "${_outcome}" "$@";
}

# fun: LOGGING.numberOfNestedInProgressTasks
# api: private
# txt: Retrieves the number of "in-progress" tasks pending.
# txt: Returns such count.
# use: LOGGING.numberOfNestedInProgressTasks; local count=$?;
function LOGGING.numberOfNestedInProgressTasks() {
  local -i _rescode;

  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_STACK;
  local -n _logStack=${RESULT};

  _rescode=${#_logStack[@]};

  return ${_rescode};
}

# fun: LOGGING.openLogLine
# api: private
# txt: Opens the log line.
# txt: Returns 0/TRUE always.
# use: LOGGING.openLogLine;
function LOGGING.openLogLine() {
  LOGGING.getModuleName;
  DW.setGlobalInt "${RESULT}" LOG_LINE_OPEN ${TRUE};
}

# fun: LOGGING.peekLog
# api: private
# txt: Peeks given message from top of the log stack.
# txt: Returns 0/TRUE if the stack contains at least the returned item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the message.
# use: if LOGGING.peekLog; then echo "Last log: ${RESULT}"; fi
function LOGGING.peekLog() {
  local -i _rescode;
  local _result="";

  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_STACK;
  local -n _logStack=${RESULT};

  local -i _len=${#_logStack[@]};
  local -i _newLen;
  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    _result="${_logStack[${_newLen}]}";
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: LOGGING.peekLogCategory
# api: private
# txt: Peeks given category from the log category stack.
# txt: Returns 0/TRUE if the stack contained at least the returned item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the category.
# use: if LOGGING.peekLogCategory; then echo "Last log category: ${RESULT}"; fi
function LOGGING.peekLogCategory() {
  local -i _rescode;
  local _result="";

  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_CATEGORY_STACK;
  local -n _logCategoryStack=${RESULT};

  local -i _len=${#_logCategory[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    _result="${_logCategoryStack[${_newLen}]}";
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: LOGGING.peekLogLevel
# api: private
# txt: Peeks given level from the log level stack.
# txt: Returns 0/TRUE if the stack contained at least the returned item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the level.
# use: if LOGGING.peekLogLevel; then echo "Last log level: ${RESULT}"; fi
function LOGGING.peekLogLevel() {
  local -i _rescode;
  local _result="";

  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_LEVEL_STACK;
  local -n _logLevelStack=${RESULT};

  local -i _len=${#_logLevelStack[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    _result="${_logLevelStack[${_newLen}]}";
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: LOGGING.popLog
# api: private
# txt: Pops given message from the log stack.
# txt: Returns 0/TRUE if the stack contained at least the popped item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the popped message.
# use: if LOGGING.popLog; then echo "Last log: ${RESULT}"; fi
function LOGGING.popLog() {
  local -i _rescode;
  local _result="";

  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_STACK;
  local -n _logStack=${RESULT};

  local -i _len=${#_logStack[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    result="${_logStack[${_newLen}]}";
    eval "unset _logStack[${_newLen}]";
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: LOGGING.popLogCategory
# api: private
# txt: Pops given category from the log category stack.
# txt: 0/TRUE if the stack contained at least the popped item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the popped category.
# use: if LOGGING.popLogCategory; then echo "Last log category: ${RESULT}"; fi
function LOGGING.popLogCategory() {
  local -i _rescode;

  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_CATEGORY_STACK;
  local -n _logCategoryStack=${RESULT};

  local -i _len=${#_logCategoryStack[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    export RESULT="${_logCategoryStack[${_newLen}]}";
    eval "unset _logCategoryStack[${_newLen}]";
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# fun: LOGGING.popLogLevel
# api: private
# txt: Pops given level from the log level stack.
# txt: Returns 0/TRUE if the stack contained at least the popped item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the popped level.
# use: if LOGGING.popLogLevel; then echo "Last log level: ${RESULT}"; fi
function LOGGING.popLogLevel() {
  local -i _rescode;
  local -i _newLen;

  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_LEVEL_STACK;
  local -n _logLevelStack=${RESULT};
  local -i _len=${#_logLevelStack[@]};

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    export RESULT="${_logLevelStack[${_newLen}]}";
    eval "unset _logLevelStack[${_newLen}]";
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# fun: LOGGING.pushLog
# api: private
# txt: Pushes given message to the log stack.
# opt: message: The message to push.
# txt: Returns 0/TRUE always.
# use: LOGGING.pushLog "Operation in progress";
function LOGGING.pushLog() {
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_STACK;
  local -n _logStack=${RESULT};
  _logStack[${#_logStack[@]}]="$*";
}

# fun: LOGGING.pushLogCategory
# api: private
# txt: Pushes given category to the log category stack.
# opt: category: The category to push.
# txt: Returns 0/TRUE always.
# use: LOGGING.pushLogCategory "sending-data";
function LOGGING.pushLogCategory() {
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_CATEGORY_STACK;
  local -n _logCategoryStack=${RESULT};
  _logCategoryStack[${#_logCategoryStack[@]}]="$*";
}

# fun: LOGGING.pushLogLevel level
# api: private
# txt: Pushes given level to the log level stack.
# opt: level: The level to push.
# txt: Returns 0/TRUE always.
# use: LOGGING.pushLogLevel INFO
function LOGGING.pushLogLevel() {
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_LEVEL_STACK;
  local -n _logLevelStack=${RESULT};
  _logLevelStack[${#_logLevelStack[@]}]="$*";
}

# fun: LOGGING.retrieveCategoryPositionInLogPrefix
# api: private
# txt: Retrieves the position of the category in the log prefix tokens array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the category position.
# use: LOGGING.retrieveCategoryPositionInLogPrefix; echo "category -> ${RESULT}";
function LOGGING.retrieveCategoryPositionInLogPrefix() {
  LOGGING.getModuleName;
  DW.getGlobalInt "${RESULT}" LOG_PREFIX_CATEGORY_POSITION;
}

# fun: LOGGING.retrieveKeywordColor
# api: private
# txt: Retrieves the color for a given keyword.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The keyword (SUCCESS, FAILURE, IN_PROGRESS).
# opt: defaultColor: The default color.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the associated color.
# use: LOGGING.retrieveKeywordColor SUCCESS GREEN; echo "Color -> ${RESULT}";
function LOGGING.retrieveKeywordColor() {
  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 1;
  LOGGING.getModuleName;
  local _moduleName="${RESULT}";
  DW.getGlobalString "${_moduleName}" NO_COLOR;
  local _noColor="${RESULT}";
  local _defaultColor="${2:-${_noColor}}";

  local result;

  DW.getGlobalString "${_moduleName}" SUCCESS_COLOR;
  local _successColor="${RESULT}";
  DW.getGlobalString "${_moduleName}" FAILURE_COLOR;
  local _failureColor="${RESULT}";
  DW.getGlobalString "${_moduleName}" IN_PROGRESS_COLOR;
  local _inProgressColor="${RESULT}";

  case ${_keyword} in
    SUCCESS | "${SUCCESS}") result="${_successColor}";
                            ;;
    FAILURE | "${FAILURE}" | "${FAILED}" | "FAILED" | "failed" | "FAIL" | "fail" | "${KO}") result="${_failureColor}";
                                                                                            ;;
    IN_PROGRESS | "${IN_PROGRESS}") result="${_inProgressColor}";
                                    ;;
    *) result="${_defaultColor}";
       ;;
  esac

  export RESULT="${result}";
}

# fun: LOGGING.retrieveLevelPositionInLogPrefix
# api: private
# txt: Retrieves the position of the log level in the log prefix tokens array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the level position.
# use: LOGGING.retrieveLevelPositionInLogPrefix; echo "level -> ${RESULT}";
function LOGGING.retrieveLevelPositionInLogPrefix() {
  LOGGING.getModuleName;
  DW.getGlobalInt "${RESULT}" LOG_PREFIX_LEVEL_POSITION;
}

# fun: LOGGING.retrieveLogNamespace
# api: private
# txt: Retrieves the log namespace.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log namespace.
# use: LOGGING.retrieveLogNamespace; echo "namespace: ${RESULT}";
function LOGGING.retrieveLogNamespace() {
  LOGGING.getModuleName;
  local _moduleName="${RESULT}";
  DW.getGlobalString "${_moduleName}" LOG_CATEGORY_NAMESPACE;
  local _namespace="${RESULT}";
  DW.getGlobalString "${_moduleName}" LOG_CATEGORY;
  local _category="${RESULT}";
  DW.getScriptName;
  local _scriptName="${RESULT}";

  local _result;

  if isEmpty "${_namespace}"; then
    if isEmpty "${_scriptName}" ; then
      _result="?";
    else
      _result="$(basename ${_scriptName} .sh)";
    fi
  fi

  if isNotEmpty ${_category} ; then
    _result="${_result}:${_category}";
  fi

  export RESULT="${_result}";
}

# fun: LOGGING.retrieveLogOutcomeColors
# api: private
# txt: Retrieves the tokens composing the log outcome.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The keyword (SUCCESS, FAILURE, IN_PROGRESS).
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the output file to source to be able to use _DRY_WIT_LOG_OUTCOME_COLORS array.
# use: LOGGING.retrieveLogOutcomeColors SUCCESS "done"; source ${RESULT}; echo "${_DRY_WIT_LOG_OUTCOME_COLORS[*]}";
function LOGGING.retrieveLogOutcomeColors() {
  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 1;

  local result=();
  local _aux="";
  LOGGING.retrieveKeywordColor "${_keyword}";
  local _keywordColor="${RESULT}";
  local -i _i;
  local -i _len;
  local -i _outcomeTextPosition;

  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_OUTCOME_COLORS;
  local -n _logOutcomeColors=${RESULT}
  _len=$((${#_logOutcomeColors[@]} - 1));

  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    IFS="${_oldIFS}";
    _logOutcomeColors[${_i}]="${_logOutcomeColors[${_i}]}";
  done
  IFS="${_oldIFS}";

  LOGGING.retrieveOutcomeTextPositionInLogOutcome;
  _outcomeTextPosition=${RESULT};
  _logOutcomeColors[${_outcomeTextPosition}]="${_keywordColor}";
}

# fun: LOGGING.retrieveLogOutcomeTokens
# api: private
# txt: Retrieves the tokens composing the log outcome.
# opt: text: The outcome text.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the output file to source to be able to use _DRY_WIT_LOG_OUTCOME_TOKENS array.
# use: LOGGING.retrieveLogOutcomeTokens "done"; source ${RESULT}; echo "${_DRY_WIT_LOG_OUTCOME_TOKENS[*]}";
function LOGGING.retrieveLogOutcomeTokens() {
  local _text="${1}";
  checkNotEmpty "text" "${_text}" 1;

  local result=();
  local _aux="";
  local _timestamp;
  local -i _i;
  local -i _len;
  local -i _outcomeTextPosition;

  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_OUTCOME_TOKENS;
  local -n _logOutcomeTokens=${RESULT};
  _len=$((${#_logOutcomeTokens[@]} - 1));

  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    _logOutcomeTokens[${_i}]="${_logOutcomeTokens[${_i}]}";
  done
  IFS="${_oldIFS}";

  LOGGING.retrieveOutcomeTextPositionInLogOutcome;
  _outcomeTextPosition=${RESULT};
  _logOutcomeTokens[${_outcomeTextPosition}]="${_text}";
}

# fun: LOGGING.retrieveLogPrefix
# api: private
# txt: Retrieves the log prefix.
# opt: category: The log category.
# opt: level: The log level.
# txt: Returns 0/TRUE always.
# use: LOGGING.retrieveLogPrefix "cat" DEBUG; echo "log prefix -> ${RESULT}";
function LOGGING.retrieveLogPrefix() {
  local _category="${1}";
  checkNotEmpty "category" "${_category}" 1;

  local _level="${2}";
  checkNotEmpty "level" "${_level}" 2;

  local _result="$(LOGGING.echoColorAwareLogPrefix "${_category}" ${FALSE} "${_level}")";
  export RESULT="${_result}";
}

# fun: LOGGING.retrieveLogPrefixToken
# api: private
# txt: Retrieves the log prefix token, depending on the given log level.
# txt: level: The log level.
# txt: Returns 0/TRUE if the token is defined; 1/FALSE otherwise.
# txt: if the function returns 0/TRUE, The variable RESULT contains the log prefix token.
# use: if LOGGING.retrieveLogPrefixToken TRACE; then echo "Log prefix token: ${RESULT}"; fi
function LOGGING.retrieveLogPrefixToken() {
  local _levelVar="${1}";
  local -i _rescode;
  checkNotEmpty level "${_levelVar}" 1;
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" "${_levelVar}_LOG_PREFIX_TOKEN";
  _rescode=$?;

  return ${_rescode};
}

# fun: LOGGING.retrieveLogPrefixTokens
# api: private
# txt: Retrieves the tokens composing the log prefix.
# opt: category: The log category.
# opt: level: The log level (optional).
# txt: Returns 0/TRUE always.
# use: LOGGING.retrieveLogPrefixTokens "a:b:c" DEBUG; echo "${RESULT}";
function LOGGING.retrieveLogPrefixTokens() {
  local _category="${1}";
  checkNotEmpty "category" "${_category}" 1;

  local _levelVar="${2:-INFO}";
  LOGGING.retrieveLogPrefixToken "${_levelVar}";
  local _level="${RESULT}";
  local result=();
  local _aux="";
  local _timestamp;
  local -i _i;
  local -i _lastIndex;
  local -i _timestampPosition;
  local -i _category_position;
  local -i _levelPosition;

  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_PREFIX_TOKENS;
  local -n _logPrefixTokens=${RESULT};
  _lastIndex=$((${#_logPrefixTokens[@]} - 1));

  local _oldIFS="${IFS}";
  #  IFS=$' \t\n';
  IFS="${DWIFS}";
  for _i in $(seq 0 ${_lastIndex}); do
    IFS="${_oldIFS}";
    _logPrefixTokens[${_i}]="${_logPrefixTokens[${_i}]}";
  done
  IFS="${_oldIFS}";

  LOGGING.retrieveLogTimestamp;
  _timestamp="${RESULT}";
  LOGGING.retrieveTimestampPositionInLogPrefix;
  _timestampPosition=${RESULT};
  _logPrefixTokens[${_timestampPosition}]="${_timestamp}";
  LOGGING.retrieveCategoryPositionInLogPrefix;
  _categoryPosition=${RESULT};
  _logPrefixTokens[${_categoryPosition}]="${_category}";
  LOGGING.retrieveLevelPositionInLogPrefix;
  _levelPosition=${RESULT};
  _logPrefixTokens[${_levelPosition}]="${_level}";
}

# fun: LOGGING.retrieveLogTimestamp
# api: private
# txt: Retrieves the timestamp used for logging.
# txt: Override LOG_TIMESTAMP to modify the timestamp format.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the timestamp.
# use: LOGGING.retrieveLogTimestamp; echo "The log timestamp is ${RESULT}";
function LOGGING.retrieveLogTimestamp() {
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" LOG_TIMESTAMP;
  export RESULT="$(date "${RESULT}")";
}

# fun: LOGGING.retrieveOutcomeTextPositionInLogOutcome
# api: private
# txt: Retrieves the position of the outcome token in the log outcome colors array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the outcome text position.
# use: LOGGING.retrieveOutcomeTextPositionInLogOutcome; echo "outcome text -> ${RESULT}";
function LOGGING.retrieveOutcomeTextPositionInLogOutcome() {
  LOGGING.getModuleName;
  DW.getGlobalInt "${RESULT}" LOG_OUTCOME_TEXT_POSITION;
}

# fun: LOGGING.retrieveTimestampPositionInLogPrefix
# api: private
# txt: Retrieves the position of the timestamp in the log prefix tokens array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the timestamp position.
# use: LOGGING.retrieveTimestampPositionInLogPrefix; echo "timestamp -> ${RESULT}";
function LOGGING.retrieveTimestampPositionInLogPrefix() {
  LOGGING.getModuleName;
  DW.getGlobalInt "${RESULT}" LOG_PREFIX_TIMESTAMP_POSITION;
}

# fun: LOGGING.setLastLog
# api: private
# txt: Annotates the last log message.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: LOGGING.setLastLog "Operation in progress";
function LOGGING.setLastLog() {
  LOGGING.getModuleName;
  DW.setGlobalString "${RESULT}" LAST_LOG "${@}";
}

# fun: getLastLog
# api: public
# txt: Retrieves the last log message.
# txt: Returns 0/TRUE always.
# txt: RESULT contains the last log.
# use: getLastLog; echo "Last log: ${RESULT}";
function LOGGING.setLastLog() {
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" LAST_LOG;
}

# fun: logInfo
# api: public
# txt: Logs a message as "info".
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: logInfo "Operation in progress";
function logInfo() {
  if isInfoEnabled; then
    checkNotEmpty "message" "${1}" 1;
    LOGGING.logStuff INFO "$@";
  fi
}

# fun: logInfoFile
# api: public
# txt: Logs the contents of a file as "info".
# opt: file: The file containing the text to log.
# txt: Returns 0/TRUE always.
# use: logInfoFile /tmp/my-log.txt;
function logInfoFile() {
  if isInfoEnabled; then
    checkNotEmpty "file" "${1}" 1;
    cat "${1}" | while IFS='' read -r line; do LOGGING.logStuff INFO "${line}"; done
  fi
}

# fun: logInfoResult
# api: public
# txt: Logs the outcome of an operation as "info"
# opt: SUCCESS|FAILURE: The outcome.
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: logInfoResult SUCCESS "done";
function logInfoResult() {
  local _outcome="${1}";
  shift;
  local _message="${@}";

  if isInfoEnabled; then
    checkNotEmpty "outcome" "${_outcome}" 1;
    checkNotEmpty "message" "${_message}" 2;
    LOGGING.logStuffResult INFO "${_outcome}" "${_message}";
  fi
}

# fun: logResult
# api: public
# txt: Logs the outcome of an operation, as "info", under a certain level.
# txt: The level is assumed to be enabled already.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: SUCCESS|FAILURE: The outcome.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: logResult SUCCESS "done";
function logResult() {
  local _level="${1}";
  shift;
  local _outcome="${1}";
  shift;
  local _message="${@}";
  checkNotEmpty "level" "${_level}" 1;
  checkNotEmpty "outcome" "${_outcome}" 2;
  checkNotEmpty "message" "${_message}" 3;

  logResult "${_level}" "${_outcome}" "${_message}";
}

# fun: logTrace
# api: public
# txt: Logs given message under the "trace" level.
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: logTrace "Operation in progress";
function logTrace() {
  if isTraceEnabled; then
    checkNotEmpty "message" "${1}" 1;
    LOGGING.logStuff TRACE "$@";
  fi
}

# fun: logTraceFile
# api: public
# txt: Logs the contents of given file, under the "trace" level.
# opt: file: The file to log.
# txt: Returns 0/TRUE always.
# use: logTraceFile /tmp/my-log.txt;
function logTraceFile() {
  if isTraceEnabled; then
    checkNotEmpty "file" "${1}" 1;
    cat "${1}" 2> /dev/null | while IFS='' read -r line; do LOGGING.logStuff TRACE "${line}"; done
  fi
}

# fun: logTraceResult
# api: public
# txt: Logs given text as a log result, under the "trace" level.
# opt: keyword: The keyword.
# opt: message: The result message to log.
# txt: Returns 0/TRUE always.
# use: logTraceResult SUCCESS "Operation completed";
function logTraceResult() {
  local _outcome="${1}";
  shift;
  local _message="${@}";

  if isTraceEnabled; then
    checkNotEmpty "outcome" "${_outcome}" 1;
    checkNotEmpty "message" "${_message}" 2;
    LOGGING.logStuffResult TRACE "${_outcome}" "${_message}";
  fi
}

# fun: resolveVerbosity
# api: public
# txt: Retrieves the verbosity flag.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains '-vv' if trace is enabled; '-v' if debug is enabled; empty string otherwise.
# use: resolveVerbosity;
function resolveVerbosity() {
  local result="";

  if isTraceEnabled; then
    result="-vv";
  elif isDebugEnabled; then
    result="-v";
  elif isInfoEnabled; then
    result="";
  fi;

  export RESULT="${result}";
}

# fun: setDebugEnabled
# api: public
# txt: Enables the "debug" level.
# txt: Returns 0/TRUE always.
# use: setDebugEnabled
function setDebugEnabled() {
  LOGGING.getModuleName;
  DW.setGlobalInt "${RESULT}" LOG_DEBUG ${TRUE};
  setInfoEnabled;
}

# fun: setInfoEnabled
# api: public
# txt: Enables the "info" level.
# txt: Returns 0/TRUE always.
# use: setInfoEnabled;
function setInfoEnabled() {
  setQuietMode ${FALSE};
  LOGGING.getModuleName;
  DW.setGlobalInt "${RESULT}" LOG_INFO ${TRUE};
}

# fun: setLogCategory
# api: public
# txt: Specifies the log category.
# opt: category: The log category.
# txt: Returns 0/TRUE always.
# use: setLogCategory;
function setLogCategory() {
  local _category="${1}";

  LOGGING.getModuleName;
  DW.setGlobalString "${RESULT}" LOG_CATEGORY "${_category}";
}

# fun: setLogCategoryNamespace
# api: public
# txt: Sets the log category namespace.
# opt: namespace: The namespace.
# txt: Returns 0/TRUE always.
# use: setLogCategoryNamespace "processing";
function setLogCategoryNamespace() {
  local _namespace="${1}";
  checkNotEmpty namespace "${_namespace}" 1;

  LOGGING.getModuleName;
  DW.setGlobalString "${RESULT}" LOG_CATEGORY_NAMESPACE "${_namespace}";
}

# fun: setQuietMode
# api: public
# txt: Sets the quiet mode on or off.
# opt: mode: The mode (0/TRUE or 1/FALSE).
# txt: Returns 0/TRUE always.
# use: setQuietMode ${TRUE};
function setQuietMode() {
  local _mode="${1}";
  checkNotEmpty "mode" "${_mode}" 1;

  LOGGING.getModuleName;
  DW.setGlobalInt "${RESULT}" LOG_QUIET ${_mode};
}

# fun: setTraceEnabled
# api: public
# txt: Enables the trace level.
# txt: Returns 0/TRUE always.
# use: setTraceEnabled;
function setTraceEnabled() {
  LOGGING.getModuleName;
  DW.setGlobalInt "${RESULT}" LOG_TRACE ${TRUE};
  setDebugEnabled;
}

# State
# env: SUCCESS: Indicates the operation has succeeded.
declare -igx SUCCESS=0;
# env: FAILURE: Indicates the operation has failed.
declare -igx FAILURE=1;
# env: IN_PROGRESS: Indicates the operation is in progress.
declare -igx IN_PROGRESS=2;
# env: UNDEFINED: Indicates the operation outcome is undefined.
declare -igx UNDEFINED=255;
# env: SUCCESS: The 'Success' literal.
declare -gx SUCCESS="Success";
# env: DONE: The 'done' literal.
declare -gx DONE="done";
# env: OK: The 'ok' literal.
declare -gx OK="ok";
# env: FAILURE: The 'Failure' literal.
declare -gx FAILURE="Failure";
# env: FAILED: The 'failed' literal.
declare -gx FAILED="failed";
# env: KO: The 'ko' literal.
declare -gx KO="ko";
# env: The built-in success keywords.
declare -agx BUILTIN_SUCCESS_KEYWORDS=("${SUCCESS}" "${DONE}" "${OK}");
# env: The built-in failure keywords.
declare -agx BUILTIN_FAILURE_KEYWORDS=("${ERROR}" "${FAILURE}" "${FAILED}" "${KO}");

# fun: LOGGING.resetState
# api: private
# txt: Initializes the logging state, depending on the script nesting level.
# txt: Returns 0/TRUE always.
# use: LOGGING.resetState
function LOGGING.resetState() {
  LOGGING.getModuleName;
  local _moduleName="${RESULT}";
  DW.declareGlobalArray "${_moduleName}" LOG_STACK;
  DW.declareGlobalArray "${_moduleName}" LOG_CATEGORY_STACK;
  DW.declareGlobalString "${_moduleName}" LOG_CATEGORY_NAMESPACE;
  DW.declareGlobalString "${_moduleName}" LOG_LEVEL_STACK;
  DW.declareGlobalInt "${_moduleName}" LOG_TRACE ${FALSE};
  DW.declareGlobalInt "${_moduleName}" LOG_DEBUG ${FALSE};
  DW.declareGlobalInt "${_moduleName}" LOG_INFO ${TRUE};
  DW.declareGlobalInt "${_moduleName}" LOG_QUIET ${FALSE};
  DW.declareGlobalArray "${_moduleName}" LOG_OUTCOME_TOKENS;
  DW.declareGlobalArray "${_moduleName}" LOG_OUTCOME_COLORS;
  DW.declareGlobalInt "${_moduleName}" DEFAULT_TERM_WIDTH;
  DW.declareGlobalInt "${_moduleName}" LOG_LINE_OPEN ${FALSE};
  DW.declareGlobalString "${_moduleName}" LAST_LOG;
  DW.declareGlobalInt "${_moduleName}" LAST_LOG_LEVEL;
  DW.declareGlobalString "${_moduleName}" NESTED_TASK_IN_PROGRESS "....";
  DW.declareGlobalString "${_moduleName}" LOG_TIMESTAMP "+%Y/%m/%d %H:%M:%S";
  DW.declareGlobalString "${_moduleName}" LOG_OUTCOME_SEPARATOR " ";
  DW.declareGlobalString "${_moduleName}" LOG_NESTED_INDENTATION "  ";

  # env: SUCCESS_COLOR: The color used to indicate the operation succeeded.
  DW.declareGlobalString "${_moduleName}" SUCCESS_COLOR GREEN;
  # env: FAILURE_COLOR: The color used to indicate the operation failed.
  DW.declareGlobalString "${_moduleName}" FAILURE_COLOR RED;
  # env: IN_PROGRESS_COLOR: The color used to indicate the operation is in progress.
  DW.declareGlobalString "${_moduleName}" IN_PROGRESS_COLOR BLUE;
  # env: UNDEFINED_COLOR: The color used to indicate unknown operation outcomes.
  DW.declareGlobalString "${_moduleName}" UNDEFINED_COLOR GRAY;
  # env: DEFAULT_LOG_PREFIX_COLOR: The default color used for log prefixes.
  DW.declareGlobalString "${_moduleName}" DEFAULT_LOG_PREFIX_COLOR GRAY;
  # env: DEFAULT_LOG_OUTCOME_COLOR: The default color used for outcomes.
  DW.declareGlobalString "${_moduleName}" DEFAULT_LOG_OUTCOME_COLOR GRAY;
  # env: DEFAULT_LOG_RESUMING_TASK_COLOR: The default color used when resuming tasks.
  DW.declareGlobalString "${_moduleName}" DEFAULT_LOG_RESUMING_TASK_COLOR GRAY;

  # env: LOG_PFEFIX_COLORS: The colors used in log prefixes.
  DW.declareGlobalArray "${_moduleName}" LOG_PREFIX_COLORS BLUE CYAN YELLOW MAGENTA YELLOW RED BLUE;

  # env: LOG_PREFIX_TOKENS: The tokens used in log prefixes.
  DW.declareGlobalArray "${_moduleName}" LOG_PREFIX_TOKENS "[" "timestamp" "<" "category" ">" "logLevel" "]";

  # env: LOG_PREFIX_TIMESTAMP_POSITION: The position of the timestamp in LOG_PREFIX_TOKENS.
  DW.declareGlobalInt "${_moduleName}" LOG_PREFIX_TIMESTAMP_POSITION 1;
  # env: LOG_PREFIX_CATEGORY_POSITION: The position of the category in LOG_PREFIX_TOKENS.
  DW.declareGlobalInt "${_moduleName}" LOG_PREFIX_CATEGORY_POSITION 3;
  # env: LOG_PREFIX_LEVEL_POSITION: The position of the level in LOG_PREFIX_TOKENS.
  DW.declareGlobalInt "${_moduleName}" LOG_PREFIX_LEVEL_POSITION 5;

  # env: INFO_LOG_PREFIX_TOKEN: The symbol used to represent INFO level.
  DW.declareGlobalString "${_moduleName}" INFO_LOG_PREFIX_TOKEN ".";
  # env: DEBUG_LOG_PREFIX_TOKEN: The symbol used to represent DEBUG level.
  DW.declareGlobalString "${_moduleName}" DEBUG_LOG_PREFIX_TOKEN "o";
  # env: TRACE_LOG_PREFIX_TOKEN: The symbol used to represent TRACE level.
  DW.declareGlobalString "${_moduleName}" TRACE_LOG_PREFIX_TOKEN "O";

  # env: LOG_OUTCOME_COLORS: The colors used when printing the operation outcome.
  DW.declareGlobalArray "${_moduleName}" LOG_OUTCOME_COLORS CYAN WHITE CYAN;

  # env: LOG_OUTCOME_TOKENS: The tokens used when printing the operation outcome.
  DW.declareGlobalArray "${_moduleName}" LOG_OUTCOME_TOKENS "[" "done" "]";

  # env: LOG_OUTCOME_TEXT_POSITION: The position of the text in LOG_OUTCOME_TOKENS.
  DW.declareGlobalInt "${_moduleName}" LOG_OUTCOME_TEXT_POSITION 1;
}

LOGGING.resetState;
#
