# Logging functions

#export SUCCESS_KEYWORDS;
#export FAILURE_KEYWORDS;

export SUCCESS=0;
export FAILURE=1;
export IN_PROGRESS=2;
export UNDEFINED=255;

if [ -z ${_DRY_WIT_LOG_STACK+x} ]; then
  export _DRY_WIT_LOG_STACK=();
fi

if [ -z ${_DRY_WIT_LOG_CATEGORY_STACK+x} ]; then
  export _DRY_WIT_LOG_CATEGORY_STACK=();
fi

if [ -z ${LOG_CATEGORY_NAMESPACE+x} ]; then
  export LOG_CATEGORY_NAMESPACE="";
fi

if [ -z ${_DRY_WIT_LOG_LEVEL_STACK+x} ]; then
  export _DRY_WIT_LOG_LEVEL_STACK=();
fi

if [ -z ${_DRY_WIT_LOG_TRACE+x} ]; then
  export _DRY_WIT_LOG_TRACE=${FALSE};
fi

if [ -z ${_DRY_WIT_LOG_DEBUG+x} ]; then
  export _DRY_WIT_LOG_DEBUG=${FALSE};
fi

if [ -z ${_DRY_WIT_LOG_INFO+x} ]; then
  export _DRY_WIT_LOG_INFO=${TRUE};
fi

if [ -z ${_DRY_WIT_LOG_OUTCOME_TOKENS+x} ]; then
  export _DRY_WIT_LOG_OUTCOME_TOKENS=();
fi

if [ -z ${_DRY_WIT_LOG_OUTCOME_COLORS+x} ]; then
  export _DRY_WIT_LOG_OUTCOME_COLORS=();
fi

if [ -z ${_DRY_WIT_DEFAULT_TERM_WIDTH+x} ]; then
  export _DRY_WIT_DEFAULT_TERM_WIDTH=80;
fi

if [ -z ${_DRY_WIT_LOG_LINE_OPEN+x} ]; then
  export _DRY_WIT_LOG_LINE_OPEN=${FALSE};
fi

if [ -z ${NESTED_TASK_IN_PROGRESS+x} ]; then
  export NESTED_TASK_IN_PROGRESS="....";
fi

if [ -z ${LOG_TIMESTAMP+x} ]; then
  export LOG_TIMESTAMP="+%Y/%m/%d %H:%M:%S";
fi

if [ -z ${LOG_OUTCOME_SEPARATOR+x} ]; then
  export LOG_OUTCOME_SEPARATOR=" ";
fi

if [ -z ${LOG_NESTED_INDENTATION+x} ]; then
  export LOG_NESTED_INDENTATION="  ";
fi

if [ -z ${_DW_SUCCESS+x} ]; then
  export _DW_SUCCESS="Success";
fi

if [ -z ${_DW_DONE+x} ]; then
  export _DW_DONE="done";
fi

if [ -z ${_DW_OK+x} ]; then
  export _DW_OK="ok";
fi

if [ -z ${SUCCESS+x} ]; then
    export SUCCESS="${_DW_SUCCESS}";
fi
if [ -z ${DONE+x} ]; then
    export DONE="${_DW_DONE}";
fi

if [ -z ${BUILTIN_SUCCESS_KEYWORDS+x} ]; then
  export BUILTIN_SUCCESS_KEYWORDS=(\
    "${_DW_SUCCESS}" \
    "${_DW_DONE}" \
    "${_DW_OK}" \
    );
fi

if [ -z ${_DW_ERROR+x} ]; then
  export _DW_ERROR="Error";
fi

if [ -z ${_DW_FAILURE+x} ]; then
  export _DW_FAILURE="Failure";
fi

if [ -z ${_DW_FAILED+x} ]; then
  export _DW_FAILED="failed";
fi

if [ -z ${_DW_KO+x} ]; then
  export _DW_KO="ko";
fi

if [ -z ${FAILURE+x} ]; then
    export FAILURE="${_DW_FAILURE}";
fi
if [ -z ${FAILED+x} ]; then
    export FAILED="${_DW_FAILED}";
fi

if [ -z ${BUILTIN_FAILURE_KEYWORDS+x} ]; then
  export BUILTIN_FAILURE_KEYWORDS=(\
    "${_DW_ERROR}" \
    "${_DW_FAILURE}" \
    "${_DW_FAILED}" \
    "${_DW_KO}" \
    );
fi

buildColor "NO_COLOR" "0";
buildColor "BLACK" "30" "0";
buildColor "RED" "31" "41";
buildColor "GREEN" "32" "42";
buildColor "YELLOW" "33" "43";
buildColor "BLUE" "34" "44";
buildColor "MAGENTA" "35" "45";
buildColor "CYAN" "36" "46";
buildColor "GRAY" "37" "47";

export SUCCESS_COLOR=GREEN;
export FAILURE_COLOR=RED;
export IN_PROGRESS_COLOR=BLUE;
export UNDEFINED_COLOR=GRAY;
export DEFAULT_LOG_PREFIX_COLOR=GRAY;
export DEFAULT_LOG_OUTCOME_COLOR=GRAY;
export DEFAULT_LOG_RESUMING_TASK_COLOR=GRAY;

export LOG_PREFIX_COLORS=(\
  BLUE   \
  CYAN  \
  YELLOW \
  MAGENTA    \
  YELLOW \
  RED \
  BLUE   \
);

export LOG_PREFIX_TOKENS=(\
    "[" \
    "timestamp"  \
    "<" \
    "category"  \
    ">" \
    "logLevel" \
    "]" \
);
export LOG_PREFIX_TIMESTAMP_POSITION=1;
export LOG_PREFIX_CATEGORY_POSITION=3;
export LOG_PREFIX_LEVEL_POSITION=5;

export INFO_LOG_PREFIX_TOKEN=".";
export DEBUG_LOG_PREFIX_TOKEN="o";
export TRACE_LOG_PREFIX_TOKEN="O";

export LOG_OUTCOME_COLORS=(\
    CYAN  \
    WHITE \
    CYAN  \
);

export LOG_OUTCOME_TOKENS=(\
    "[" \
    "done" \
    "]" \
);

export LOG_OUTCOME_TEXT_POSITION=1;

function setLogCategoryNamespace() {
  export LOG_CATEGORY_NAMESPACE="$1";
}

function getLogCategoryNamespace() {
  export RESULT="${LOG_CATEGORY_NAMESPACE}";
}

function setLogCategory() {
  export LOG_CATEGORY="$1";
}

function getLogCategory() {
  export RESULT="${LOG_CATEGORY}";
}

function findOutKeyword() {
  local _value="${1}";
  local result;

  case "${_value}" in
    "${_DW_SUCCESS}") result=${SUCCESS};
               ;;
    "${_DW_FAILURE}") result=${FAILURE};
               ;;
    *) if isSuccessKeyword "${_value}"; then
         result=${SUCCESS};
       elif isFailureKeyword "${_value}"; then
         result=${FAILURE};
       else
         result=${UNDEFINED};
       fi
       ;;
  esac

  return ${result};
}

# Checks whether given tag is defined.
# -> 1: The tag to check.
# <- 0/${TRUE} if the tag is defined; 1/${FALSE} otherwise.
function definedTag() {
  local result;

  case "${1}" in
    "${_DW_SUCCESS}" | "${_DW_FAILURE}") result=${TRUE};
       ;;
    *) result=${FALSE};
       ;;
  esac

  return ${result};
}

# Retrieves the verbosity flag.
# <- RESULT: -vv if trace is enabled;
#            -v if debug is enabled;
#            empty string otherwise.
function resolveVerbosity() {
  local result="";

  if isTraceEnabled; then
      result="-vv";
  elif isDebugEnabled; then
      result="-v";
  elif isInfoEnabled; then
      result="";
  fi;

  export RESULT="${result}";
}

# Checks whether trace is enabled.
# <- 0/${TRUE} if trace is enabled; 1/${FALSE} otherwise.
function isTraceEnabled() {
  local rescode=${FALSE};

  if isDebugEnabled; then
    if isTrue ${_DRY_WIT_LOG_TRACE}; then
      rescode=${TRUE};
    fi
  fi

  return ${rescode};
}

# Enables the trace level.
function setTraceEnabled() {
  _DRY_WIT_LOG_TRACE=${TRUE};
  setDebugEnabled;
}

# Logs given message under the "trace" level.
# -> 1: The message to log.
function logTrace() {
  if isTraceEnabled; then
      checkNotEmpty "outcome" "${1}" 1;
      _logStuff TRACE "$@";
  fi
}

# Logs given text as a log result, under the "trace" level.
# -> 1: The result message to log.
function logTraceResult() {
  local _outcome="${1}";
  shift;
  local _message="${@}";

  if isTraceEnabled; then
      checkNotEmpty "outcome" "${_outcome}" 1;
      checkNotEmpty "message" "${_message}" 2;
      _logStuffResult TRACE "${_outcome}" "${_message}";
  fi
}

# Logs the contents of given file, under the "trace" level.
# -> 1: The file to log.
function logTraceFile() {
  if isTraceEnabled; then
      checkNotEmpty "file" "${1}" 1;
      cat "${1}" 2> /dev/null | while IFS='' read -r line; do _logStuff TRACE "${line}"; done
  fi
}

# Checks whether the debug level is enabled.
# <- 0/${TRUE} if debug is allowed; 1/${FALSE} otherwise.
function isDebugEnabled() {
  local rescode=${FALSE};

  if isInfoEnabled; then
    if isTrue ${_DRY_WIT_LOG_DEBUG}; then
      rescode=${TRUE};
    fi
  fi

  return ${rescode};
}

# Enables the debug level.
function setDebugEnabled() {
  _DRY_WIT_LOG_DEBUG=${TRUE};
  setInfoEnabled;
}

# Logs the contents of given file, under the "debug" level.
# -> 1: The file to log.
function logDebugFile() {
  if isDebugEnabled; then
      checkNotEmpty "file" "${1}" 1;
      cat "${1}" | while IFS='' read -r line; do _logStuff DEBUG "${line}"; done
  fi
}

# Logs given message under the "debug" level.
# -> 1: The message to log.
function logDebug() {
  if isDebugEnabled; then
      checkNotEmpty "message" "${1}" 1;
      _logStuff DEBUG "$@";
  fi
}

# Logs given outcome under the "debug" level.
# -> 1: The outcome to log.
function logDebugResult() {
  local _outcome="${1}";
  shift;
  local _message="${@}";

  if isDebugEnabled; then
      checkNotEmpty "outcome" "${_outcome}" 1;
      checkNotEmpty "message" "${_message}" 2;
      _logStuffResult DEBUG "${_outcome}" "${_message}";
  fi
}

# Checks whether the enabled log level is lower than "info".
# <- 0/${TRUE} in such case; 1/${FALSE} otherwise.
function isLowerThanInfoEnabled() {
  if isDebugEnabled || isTraceEnabled; then
    return ${TRUE};
  else
    return ${FALSE};
  fi
}

function isInfoEnabled() {
  local rescode=${TRUE};

  if isQuietMode; then
    rescode=${FALSE};
  fi

  return ${rescode};
}

function setInfoEnabled() {
  _DRY_WIT_LOG_QUIET=${FALSE};
}

function logInfoFile() {
  if isInfoEnabled; then
      checkNotEmpty "file" "${1}" 1;
      cat "${1}" | while IFS='' read -r line; do _logStuff INFO "${line}"; done
  fi
}

function logInfo() {
  if isInfoEnabled; then
      checkNotEmpty "message" "${1}" 1;
      _logStuff INFO "$@";
  fi
}

function logInfoResult() {
  local _outcome="${1}";
  shift;
  local _message="${@}";

  if isInfoEnabled; then
    checkNotEmpty "outcome" "${_outcome}" 1;
    checkNotEmpty "message" "${_message}" 2;
    _logStuffResult INFO "${_outcome}" "${_message}";
  fi
}

## Sets the quiet mode on or off.
## -> 1: The mode.
## Example:
##   setQuietMode ${TRUE};
function setQuietMode() {
  local _mode="${1}";

  checkNotEmpty "mode" "${_mode}" 1;

  _DRY_WIT_LOG_QUIET=${_mode};
}

## Retrieves whether the quiet mode is on or off.
## <- 0/${TRUE} if the mode is enabled; 1/${FALSE} otherwise.
## Example:
##   if isQuietMode; then
##     echo "In quiet mode";
##   fi
function isQuietMode() {
  local -i _rescode;

  if isTrue ${_DRY_WIT_LOG_QUIET}; then
      _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

## Enables quiet mode.
## Example:
##   enableQuietMode;
function enableQuietMode() {
  setQuietMode ${TRUE};
}

## Enables quiet mode.
## Example:
##   enableQuietMode;
function disableQuietMode() {
  setQuietMode ${FALSE};
}

function log() {
  checkNotEmpty "message" "${1}" 1;
  _logInfo "$@";
}

function logResult() {
  local _outcome="${1}";
  shift;
  local _message="${@}";

  logInfoResult "${_outcome}" "${_message}";
}

function logFile() {
  checkNotEmpty "file" "${1}" 1;
  cat "${1}" | while IFS='' read -r line; do _logStuff INFO "${line}"; done
}

function _logStuff() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;
  local _minusN="${1}";
  if [ "-n" == "${_minusN}" ]; then
    shift;
  fi
  _logInProgress "${_level}" "$@";
  if [ "-n" != "${_minusN}" ]; then
    echo;
    _popLog;
    _popLogCategory;
  fi
}

function _logStuffResult() {
  local _level="${1}";
  local _outcome="${2}";

  checkNotEmpty "level" "${_level}" 1;
  shift;

  checkNotEmpty "outcome" "${_outcome}" 2;
  shift;

  checkNotEmpty "text" "${@}" 3;

  local -i _nestedTasks;
  _numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if isZero ${_nestedTasks}; then
      exitWithErrorCode UNACCEPTABLE_API_CALL "No ongoing process to print the outcome for. Review ${FUNCNAME[2]}";
  fi
  _logCompleted "${_level}" "${_outcome}" "$@";
}

## PRIVATE
## Annotates the last log message.
## -> 1: The log message.
function _setLastLog() {
  _DRY_WIT_LAST_LOG="${@}";
}

## PRIVATE
## Retrieves the last log message.
## <- RESULT: The log message.
function _getLastLog() {
  export RESULT="${_DRY_WIT_LAST_LOG}";
}

## PRIVATE
## Pushes given message to the log stack.
## -> 1: The message to push.
function _pushLog() {
  _DRY_WIT_LOG_STACK[${#_DRY_WIT_LOG_STACK[@]}]="$*";
}

## PRIVATE
## Pushes given category to the log category stack.
## -> 1: The category to push.
function _pushLogCategory() {
  _DRY_WIT_LOG_CATEGORY_STACK[${#_DRY_WIT_LOG_CATEGORY_STACK[@]}]="$*";
}

## PRIVATE
## Pushes given level to the log level stack.
## -> 1: The level to push.
function _pushLogLevel() {
  _DRY_WIT_LOG_LEVEL_STACK[${#_DRY_WIT_LOG_LEVEL_STACK[@]}]="$*";
}

## PRIVATE
## Retrieves the number of "in-progress" tasks pending.
## <- Such count.
## Example:
##   _numberOfNestedInProgressTasks;
##   _count=$?
function _numberOfNestedInProgressTasks() {
  local rescode;
  rescode=${#_DRY_WIT_LOG_STACK[@]};
  return ${rescode};
}

## PRIVATE
## Pops given message from the log stack.
## <- 0: if the stack contained at least the popped item; 1 otherwise.
## <- RESULT: The popped message.
## Example:
##   if _popLog; then
##     echo "Last log: ${RESULT}";
##   fi
function _popLog() {
  local -i rescode;
  local result="";
  local -i _len=${#_DRY_WIT_LOG_STACK[@]};
  local -i _newLen;
  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    result="${_DRY_WIT_LOG_STACK[${_newLen}]}";
    eval "unset _DRY_WIT_LOG_STACK[${_newLen}]";
    rescode=$?;
  else
    rescode=${FALSE};
  fi
  export RESULT="${result}";
  return ${rescode};
}

## PRIVATE
## Peeks given message from top of the log stack.
## <- 0: if the stack contains at least the returned item; 1 otherwise.
## <- RESULT: The message.
## Example:
##   if _peekLog; then
##     echo "Last log: ${RESULT}";
##   fi
function _peekLog() {
  local rescode;
  local result="";
  local -i _len=${#_DRY_WIT_LOG_STACK[@]};
  local -i _newLen;
  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    result="${_DRY_WIT_LOG_STACK[${_newLen}]}";
    rescode=$?;
  else
    rescode=1;
  fi
  export RESULT="${result}";
  return ${rescode};
}

## PRIVATE
## Pops given category from the log category stack.
## <- 0: if the stack contained at least the popped item; 1 otherwise.
## <- RESULT: The popped category.
## Example:
##   if _popLogCategory; then
##     echo "Last log category: ${RESULT}";
##   fi
function _popLogCategory() {
  local rescode;
  local -i _len=${#_DRY_WIT_LOG_CATEGORY_STACK[@]};
  local -i _newLen;
  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    export RESULT="${_DRY_WIT_LOG_CATEGORY_STACK[${_newLen}]}";
    eval "unset _DRY_WIT_LOG_CATEGORY_STACK[${_newLen}]";
    rescode=$?;
  else
    rescode=${FALSE};
  fi
  return ${rescode};
}

## PRIVATE
## Peeks given category from the log category stack.
## <- 0: if the stack contained at least the returned item; 1 otherwise.
## <- RESULT: The category.
## Example:
##   if _peekLogCategory; then
##     echo "Last log category: ${RESULT}";
##   fi
function _peekLogCategory() {
  local rescode;
  local result="";
  local -i _len=${#_DRY_WIT_LOG_CATEGORY_STACK[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    result="${_DRY_WIT_LOG_CATEGORY_STACK[${_newLen}]}";
    rescode=$?;
  else
    rescode=${FALSE};
  fi

  export RESULT="${result}";
  return ${rescode};
}

## PRIVATE
## Pops given level from the log level stack.
## <- 0: if the stack contained at least the popped item; 1 otherwise.
## <- RESULT: The popped level.
## Example:
##   if _popLogLevel; then
##     echo "Last log level: ${RESULT}";
##   fi
function _popLogLevel() {
  local rescode;
  local -i _len=${#_DRY_WIT_LOG_LEVEL_STACK[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    export RESULT="${_DRY_WIT_LOG_LEVEL_STACK[${_newLen}]}";
    eval "unset _DRY_WIT_LOG_LEVEL_STACK[${_newLen}]";
    rescode=$?;
  else
    rescode=${FALSE};
  fi

  return ${rescode};
}

## PRIVATE
## Peeks given level from the log level stack.
## <- 0: if the stack contained at least the returned item; 1 otherwise.
## <- RESULT: The level.
## Example:
##   if _peekLogLevel; then
##     echo "Last log level: ${RESULT}";
##   fi
function _peekLogLevel() {
  local rescode;
  local result="";
  local -i _len=${#_DRY_WIT_LOG_LEVEL_STACK[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    result="${_DRY_WIT_LOG_LEVEL_STACK[${_newLen}]}";
    rescode=$?;
  else
    rescode=${FALSE};
  fi

  export RESULT="${result}";
  return ${rescode};
}

## PRIVATE
## Checks whether the log line is currently opened.
## <- 0: if it's open; 1 otherwise.
## Example:
##   if _isLogLineOpen; then [..]; fi
function _isLogLineOpen() {
  return ${_DRY_WIT_LOG_LINE_OPEN};
}

## PRIVATE
## Opens the log line.
## Example:
##   _openLogLine;
function _openLogLine() {
  export _DRY_WIT_LOG_LINE_OPEN=${TRUE};
}

## PRIVATE
## Closes the log line.
## Example:
##   _closeLogLine;
function _closeLogLine() {
  export _DRY_WIT_LOG_LINE_OPEN=${FALSE};
}

## PRIVATE
## Retrieves the timestamp used for logging.
## <- RESULT: The timestamp.
## Note: Override LOG_TIMESTAMP to modify the timestamp format.
## Example:
##   _retrieveLogTimestamp;
##   echo "The log timestamp is ${RESULT}";
function _retrieveLogTimestamp() {
  export RESULT="$(date "${LOG_TIMESTAMP}")";
}

## PRIVATE
## Retrieves the position of the timestamp in
## the log prefix tokens array.
## <- RESULT: the timestamp position.
## Example:
##   _retrieveTimestampPositionInLogPrefix;
##   echo "timestamp -> ${RESULT}";
function _retrieveTimestampPositionInLogPrefix() {
  export RESULT=${LOG_PREFIX_TIMESTAMP_POSITION};
}

## PRIVATE
## Retrieves the position of the category in
## the log prefix tokens array.
## <- RESULT: the category position.
## Example:
##   _retrieveCategoryPositionInLogPrefix;
##   echo "category -> ${RESULT}";
function _retrieveCategoryPositionInLogPrefix() {
  export RESULT=${LOG_PREFIX_CATEGORY_POSITION};
}

## PRIVATE
## Retrieves the position of the log level in
## the log prefix tokens array.
## <- RESULT: the level position.
## Example:
##   _retrieveLevelPositionInLogPrefix;
##   echo "level -> ${RESULT}";
function _retrieveLevelPositionInLogPrefix() {
    export RESULT=${LOG_PREFIX_LEVEL_POSITION};
}

## PRIVATE
## Retrieves the position of the outcome token in
## the log outcome colors array.
## <- RESULT: the outcome text position.
## Example:
##   _retrieveOutcomeTextPositionInLogOutcome;
##   echo "outcome text -> ${RESULT}";
function _retrieveOutcomeTextPositionInLogOutcome() {
  export RESULT=${LOG_OUTCOME_TEXT_POSITION};
}

## PRIVATE
## Retrieves the tokens composing the log prefix.
## -> 1: The log category.
## -> 2: The log level (optional).
## Example:
##    _retrieveLogPrefixTokens "a:b:c" DEBUG;
##    echo "${_DRY_WIT_LOG_PREFIX_TOKENS[*]}"
function  _retrieveLogPrefixTokens() {
  local _category="${1}";
  checkNotEmpty "category" "${_category}" 1;

  local _levelVar="${2}";

  evalConstant "${_levelVar}_LOG_PREFIX_TOKEN" "${INFO_LOG_PREFIX_TOKEN}";
  local _level="${RESULT}";
  local result=();
  local _aux="";
  local _timestamp;
  local -i _i;
  local -i _len;
  local -i _timestampPosition;
  local -i _category_position;
  local -i _levelPosition;

  _len=$((${#LOG_PREFIX_TOKENS[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    _DRY_WIT_LOG_PREFIX_TOKENS[${_i}]="${LOG_PREFIX_TOKENS[${_i}]}";
  done
  IFS="${_oldIFS}";

  _retrieveLogTimestamp;
  _timestamp="${RESULT}";
  _retrieveTimestampPositionInLogPrefix;
  _timestampPosition=${RESULT};
  _DRY_WIT_LOG_PREFIX_TOKENS[${_timestampPosition}]="${_timestamp}";
  _retrieveCategoryPositionInLogPrefix;
  _categoryPosition=${RESULT};
  _DRY_WIT_LOG_PREFIX_TOKENS[${_categoryPosition}]="${_category}";
  _retrieveLevelPositionInLogPrefix;
  _levelPosition=${RESULT};
  _DRY_WIT_LOG_PREFIX_TOKENS[${_levelPosition}]="${_level}";
}

## PRIVATE
## Retrieves the tokens composing the log outcome.
## -> 1: The outcome text.
## <- RESULT: The output file to source to be able to use
##            _DRY_WIT_LOG_OUTCOME_TOKENS array.
## Example:
##    _retrieveLogOutcomeTokens "done";
##    source ${RESULT};
##    echo "${_DRY_WIT_LOG_OUTCOME_TOKENS[*]}"
function  _retrieveLogOutcomeTokens() {
  local _text="${1}";
  checkNotEmpty "text" "${_text}" 1;

  local result=();
  local _aux="";
  local _timestamp;
  local -i _i;
  local -i _len;
  local -i _outcomeTextPosition;

  _len=$((${#LOG_OUTCOME_TOKENS[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    _DRY_WIT_LOG_OUTCOME_TOKENS[${_i}]="${LOG_OUTCOME_TOKENS[${_i}]}";
  done
  IFS="${_oldIFS}";

  _retrieveOutcomeTextPositionInLogOutcome;
  _outcomeTextPosition=${RESULT};
  _DRY_WIT_LOG_OUTCOME_TOKENS[${_outcomeTextPosition}]="${_text}";

}

## PRIVATE
## Retrieves the tokens composing the log outcome.
## -> 1: The keyword (SUCCESS, FAILURE, IN_PROGRESS).
## <- RESULT: The output file to source to be able to use
##            _DRY_WIT_LOG_OUTCOME_COLORS array.
## Example:
##    _retrieveLogOutcomeColors SUCCESS "done";
##    source ${RESULT};
##    echo "${_DRY_WIT_LOG_OUTCOME_COLORS[*]}"
function _retrieveLogOutcomeColors() {
  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 1;

  local result=();
  local _aux="";
  _retrieveKeywordColor "${_keyword}";
  local _keywordColor="${RESULT}";
  local -i _i;
  local -i _len;
  local -i _outcomeTextPosition;

  _len=$((${#LOG_OUTCOME_COLORS[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    _DRY_WIT_LOG_OUTCOME_COLORS[${_i}]="${LOG_OUTCOME_COLORS[${_i}]}";
  done
  IFS="${_oldIFS}";

  _retrieveOutcomeTextPositionInLogOutcome;
  _outcomeTextPosition=${RESULT};
  _DRY_WIT_LOG_OUTCOME_COLORS[${_outcomeTextPosition}]="${_keywordColor}";
}

## PRIVATE
## Retrieves the color for a given keyword.
## -> 1: The keyword (SUCCESS, FAILURE, IN_PROGRESS).
## -> 2: The default color.
## <- RESULT: The associated color.
## Example:
##   _retrieveKeywordColor SUCCESS GREEN;
##   echo "Color -> ${RESULT}"
function _retrieveKeywordColor() {
  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 1;
  local _defaultColor="${2:-${NO_COLOR}}";

  local result;

  case ${_keyword} in
    SUCCESS | "${SUCCESS}") result="${SUCCESS_COLOR}";
                            ;;
    FAILURE | "${FAILURE}" | "${_DW_FAILURE}" | "${_DW_FAILED}" | "FAILED" | "failed" | "FAIL" | "fail") result="${FAILURE_COLOR}";
                                                                    ;;
    IN_PROGRESS | "${IN_PROGRESS}") result="${IN_PROGRESS_COLOR}";
                                    ;;
    *) result="${_defaultColor}";
       ;;
  esac

  export RESULT="${result}";
}

## PRIVATE
## Prints the log prefix.
## -> 1: The log category.
## -> 2: The log level.
## Example:
##   _echoLogPrefix "cat" DEBUG
function _echoLogPrefix() {
  local _category="${1}";
  checkNotEmpty "category" "${_category}" 1;

  local _level="${2}";
  checkNotEmpty "level" "${_level}" 2;

  local _allowsColors;
  allowsColors;
  _allowsColors=$?;
  _echoColorAwareLogPrefix "${_category}" ${_allowsColors} "${_level}";
}

## PRIVATE
## Retrieves the log prefix.
## -> 1: The log category.
## -> 2: The log level.
## Example:
##   _retrieveLogPrefix "cat" DEBUG;
##   echo "log prefix -> ${RESULT}";
function _retrieveLogPrefix() {
  local _category="${1}";
  checkNotEmpty "category" "${_category}" 1;

  local _level="${2}";
  checkNotEmpty "level" "${_level}" 2;

  local result="$(_echoColorAwareLogPrefix "${_category}" ${FALSE} "${_level}")";
  export RESULT="${result}";
}

## PRIVATE
## Prints the log prefix, for color terminals.
## -> 1: The log category.
## -> 2: ${TRUE} if using colors; ${FALSE} otherwise.
## -> 3: The log level.
## Example:
##   _echoColorAwareLogPrefix "cat" ${TRUE} DEBUG
function _echoColorAwareLogPrefix() {
  local _category="${1}";
  checkNotEmpty "category" "${_category}" 1;

  local -i _allowsColors=${2};
  checkNotEmpty "allowsColors" "${_allowsColors}" 2;

  local _level="${3}";
  checkNotEmpty "level" "${_level}" 3;

  local _len;
  local _colors;
  local -i _i;

  _retrieveLogPrefixTokens "${_category}" "${_level}";

  _len=$((${#_DRY_WIT_LOG_PREFIX_TOKENS[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    if isTrue ${_allowsColors}; then
      echoInColor -n "${LOG_PREFIX_COLORS[${_i}]}" "${_DRY_WIT_LOG_PREFIX_TOKENS[${_i}]}";
    else
      echo -n "${_DRY_WIT_LOG_PREFIX_TOKENS[${_i}]}";
    fi
  done
  IFS="${_oldIFS}";

  if isTrue ${_allowsColors}; then
    resetColor;
  fi
  echo -n " ";
}

## PRIVATE
## Retrieves the log namespace.
## <- RESULT: The log namespace.
function _retrieveLogNamespace() {
  local _namespace="${LOG_CATEGORY_NAMESPACE}";
  local _category="${LOG_CATEGORY}";
  local result;

  if isEmpty "${_namespace}"; then
    if isEmpty "${SCRIPT_NAME}" ; then
      result="?";
    else
      result="$(basename ${SCRIPT_NAME} .sh)";
    fi
  fi

  if isNotEmpty ${_category} ; then
    result="${result}:${_category}";
  fi

  export RESULT="${result}";
}

## PRIVATE
## Prints the log outcome.
## -> 1: The log level.
## -> 2: The keyword  (SUCCESS, FAILURE, IN_PROGRESS).
## -> 3: The outcome text.
## Example:
##   _echoLogOutcome DEBUG SUCCESS "sample"
function _echoLogOutcome() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift;

  local _text="${@}";
  local _len;
  local _allowsColors;
  local _colors;
  local _inProgressMessage;
  local _logPrefix;
  local -i i;

  _retrieveLogOutcomeTokens "${_text}";

  allowsColors;
  _allowsColors=$?;

  if isTrue ${_allowsColors}; then
    _retrieveLogOutcomeColors ${_keyword};
  fi

  _peekLog;
  _inProgressMessage="${RESULT}";
  _peekLogCategory;
  _category="${RESULT}";
  if isEmpty "${_category}"; then
    exitWithErrorCode POSTCONDITION_NOT_SATISFIED "_peekLogCaterory must not return an empty string";
  fi
  _peekLogLevel;
  _level="${RESULT}";
  _retrieveLogPrefix "${_category}" "${_level}";
  _logPrefix="${RESULT}";
  _alignRight "${_logPrefix}${_inProgressMessage}" "${_text}";

  _len=$((${#_DRY_WIT_LOG_OUTCOME_TOKENS[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    if isTrue ${_allowsColors}; then
      echoInColor -n "${_DRY_WIT_LOG_OUTCOME_COLORS[${_i}]}" "${_DRY_WIT_LOG_OUTCOME_TOKENS[${_i}]}";
    else
      echo -n "${_DRY_WIT_LOG_OUTCOME_TOKENS[${_i}]}";
    fi
  done
  IFS="${_oldIFS}";

  if isTrue ${_allowsColors}; then
    resetColor;
  fi
}

## PRIVATE
## Prints the log outcome.
## -> 1: The log level.
## -> 2: The keyword  (SUCCESS, FAILURE, IN_PROGRESS).
## -> 3: The outcome text.
## Example:
##   _echoLogOutcome DEBUG SUCCESS "sample"
function _echoLogOutcomeNested() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift;

  local _text="${@}";
  local _inProgressMessage;
  local _alreadyInProgressMessage;
  local _category;
  local _alreadyInProgressCategory;
  local _indentation;
  local -i _i;
  _popLog;
  _inProgressMessage="${RESULT}";
  _popLogCategory;
  _category="${RESULT}";
  _echoLogOutcome "${_level}" "${_keyword}" "${_text}";
  _numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 1 ${_nestedTasks}); do
    _indentation="${_indentation}${LOG_NESTED_INDENTATION}";
  done
  IFS="${_oldIFS}";
  _pushLog "${_indentation}${_inProgressMessage}";
  _pushLogCategory "${_category}";
}

## PRIVATE
## Writes spaces until the next message to print
## is aligned to the right.
## -> 1: The log-line message.
## -> 2: The log outcome message.
## Example:
##  _alignRight "Finishing work" "done";
function _alignRight() {
  local _logLineMessage="${1}";
  checkNotEmpty "message" "${_logLineMessage}" 1;

  local _outcome="${2}";
  checkNotEmpty "outcome" "${_outcome}" 2;

  local _logMessage;

  local -i _termWidth;
  local -i _index;
  local -i _offset=0;
  local -i _end;
  local _allowsColors;
  local _token;

  _retrieveLogOutcomeTokens "${_outcome}";
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _token in "${_DRY_WIT_LOG_OUTCOME_TOKENS[@]}"; do
    _logMessage="${_logMessage}${_token}";
  done
  IFS="${_oldIFS}";

  getTermWidth;
  if isTrue $?; then
    _termWidth=${RESULT};
    if [ ${_termWidth} -le 0 ]; then
      exitWithErrorCode POSTCONDITION_NOT_SATISFIED "getTermWidth() must not return successfully providing 0 as output";
    fi
    _index=0;
    allowsColors;
    _allowsColors=$?;
    if isTrue ${_allowsColors}; then
      _offset=$((_offset));
    fi
    _end=$((${_offset}+${_termWidth}-${#_logLineMessage}%${_termWidth}-${#_logMessage}-1));
    while [ $((_end)) -lt 0 ]; do
      echo "";
      _end=$((-${_end}+${_offset}+${_termWidth}-${#_logMessage}));
    done
    while [ $((${_end}-${_index}+1)) != 0 ]; do
      _index=$((${_index}+1));
      echo -n "${LOG_OUTCOME_SEPARATOR}";
    done
  fi
}

## PRIVATE
## Prints a log message.
## -> 1: The log level.
## -> 2: The message.
## Example:
##   _logMessage INFO "A message to log"
##   # [...] A message to log
function _logMessage() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;

  shift;
  local _message="$@";
  checkNotEmpty "message" "${_message}" 2;
  _logInProgress "${_level}" "${_message}";
  echo;
}

## PRIVATE
## Prints a log message, indicating some uncompleted task.
## -> 1: The message.
## Example:
##   _logInProgress "Calculating ...";
##   # [...] Calculating ...
function _logInProgress() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _message="$@";
  checkNotEmpty "message" "${_message}" 2;

  local -i nestedTasks;
  local _category;
  _retrieveLogNamespace;
  _category="${RESULT}";

  _numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if [ ${_nestedTasks} -gt 0 ]; then
      _logInProgressNested "${_category}" "${_level}" "${_message}";
  else
    _logInProgressNoNested "${_category}" "${_level}" "${_message}";
  fi
}

## PRIVATE
## Prints a log message, indicating some uncompleted task,
## when there're nested tasks.
## -> 1: The category.
## -> 2: The log level.
## -> 3: The message.
## Example:
##   _logInProgressNested "cat" DEBUG "Calculating ...";
##   # [...<cat>|o] Calculating ...
function _logInProgressNested() {
  local _category="${1}";
  checkNotEmpty "category" "${_category}" 1;
  shift;

  local _level="${1}";
  checkNotEmpty "level" "${_level}" 2;
  shift;

  local _message="$@";
  checkNotEmpty "message" "${_message}" 3;

  local _logPrefix;
  _pushLog "${_message}";
  _pushLogCategory "${_category}";
  _pushLogLevel "${_level}";
  _logCompletedNestedNoPop "${_level}" IN_PROGRESS "${NESTED_TASK_IN_PROGRESS}";
  echo;

  _retrieveLogPrefix "${_category}" "${_level}";
  _logPrefix="${RESULT}";
  _echoLogPrefix "${_category}" "${_level}";
  _peekLog;
  _actualMessage="${RESULT}";
  echoColorizedText "${_actualMessage}" "" "${DEFAULT_LOG_PREFIX_COLOR}";
}

## PRIVATE
## Prints a log message, indicating some uncompleted task,
## when there're no nested tasks.
## -> 1: The log category.
## -> 2: The log level.
## -> 3: The message.
## Example:
##   _logProgressNoNested "cat" INFO "Calculating ...";
##   # [...<cat|.>] Calculating ...
function _logInProgressNoNested() {
  local _category="${1}";
  checkNotEmpty "category" "${_category}" 1;
  shift;

  local _level="${1}";
  checkNotEmpty "level" "${_level}" 2;
  shift;

  local _message="$@";
  checkNotEmpty "message" "${_message}" 3;
  local _logPrefix;

  _logPrefix="${RESULT}";
  _pushLogCategory "${_category}";
  _pushLog "${_message}";
  _pushLogLevel "${_level}";
  _echoLogPrefix "${_category}" "${_level}";
  echoColorizedText "${_message}" "" "${DEFAULT_LOG_PREFIX_COLOR}";
}

## PRIVATE
## Prints the result of a task.
## -> 1: The log level.
## -> 2: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS);
## -> 3: The outcome text.
## Example:
##   _logCompleted INFO SUCCESS "done";
function _logCompleted() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift;
  local _text="${@}";
  checkNotEmpty "text" "${_text}" 3;

  local -i nestedTasks;

  _numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if [ ${_nestedTasks} -gt 1 ]; then
    _logCompletedNested "${_level}" "${_keyword}" "${_text}";
  else
    _logCompletedNoNested "${_level}" "${_keyword}" "${_text}";
  fi
}

## PRIVATE
## Prints the result of a task.
## -> 1: The log level.
## -> 2: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS);
## -> 3: The outcome text.
## Example:
##   _logCompletedNoNested INFO SUCCESS "done";
function _logCompletedNoNested() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift;

  local _text="${@}";
  checkNotEmpty "text" "${_text}" 3;

  _echoLogOutcome "${_level}" "${_keyword}" "${_text}";
  _popLog;
  _popLogCategory;
  _popLogLevel;
  echo;
}

## PRIVATE
## Prints the result of a task, when there're nested tasks.
## -> 1: The log level.
## -> 2: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS);
## -> 3: The outcome text.
## Example:
##   _logCompletedNested INFO SUCCESS "done";
function _logCompletedNested() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift

  local _message="$@";
  checkNotEmpty "message" "${_message}" 3;

  local _nestedTask;
  local _nestedTaskCategory;
  local _logPrefix;
  _echoLogOutcome "${_level}" "${_keyword}" "${_message}";
  echo;
  _popLogCategory;
  _peekLogCategory;
  _nestedTaskCategory="${RESULT}";
  _popLogLevel;
  _peekLogLevel;
  _nestedTaskLevel="${RESULT}";
  _popLog;
  _peekLog;
  _nestedTask="${RESULT}";
  _echoLogPrefix "${_nestedTaskCategory}" "${_nestedTaskLevel}";
  echoColorizedText "${_nestedTask}" "" "${DEFAULT_LOG_RESUMING_TASK_COLOR}";
}

## PRIVATE
## Prints the result of a task, when there're nested tasks.
## -> 1: The log level.
## -> 2: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS);
## -> 3: The outcome text.
## Example:
##   _logCompletedNested SUCCESS "done";
function _logCompletedNestedNoPop() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift
  local _message="$@";
  checkNotEmpty "message" "${_message}" 3;

  _echoLogOutcomeNested "${_level}" "${_keyword}" "${_message}";
}


function logDebugFileContents() {
  if isDebugEnabled; then
    [ -f "$1" ] && sed 's ^\s+$  g' "$1" | awk '{printf("logDebug \"%s\"\n", $0);}' | sh
  fi
}

function logFlag() {
  local _flag="$1";
  local _value="$2";
  local _placeholders=$3;
  local _remaining="$4";

  if isNotEmpty "${_value}"; then
    _value=" ${_value}";
  fi
  if isNotEmpty "${_remaining}"; then
    _remaining=" Remaining ${_remaining}";
  fi
  logTrace "Parsed ${_flag} ${_value}. Shifting ${_placeholders} placeholder(s).${_remaining}";
}

# Checks whether given keyword represents a success.
# -> 1: The keyword.
# <- 0/${TRUE} if the keyword is considered a success; 1/${FALSE} otherwise.
function isSuccessKeyword() {
  local _keyword="${1}";
  local -i rescode=${FALSE};
  local _i;
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  if    isNotEmpty "${SUCCESS_KEYWORDS}" \
     && isNotEmpty ${SUCCESS_KEYWORDS[*]}; then
    for _i in ${SUCCESS_KEYWORDS[*]}; do
      if    areEqual "${_i}" "${_keyword}" \
         || areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
                     "$(echo \"${_i}\"       | tr [:upper:] [:lower:] 2> /dev/null)"; then
        rescode=${TRUE};
        break;
      fi;
    done
  fi

  if isFalse ${rescode}; then
    for _i in ${BUILTIN_SUCCESS_KEYWORDS[*]}; do
      if    areEqual "${_i}" "${1}" \
         || areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
                     "$(echo \"${_i}\"       | tr [:upper:] [:lower:] 2> /dev/null)"; then
        rescode=${TRUE};
        break;
      fi;
    done
  fi
  IFS="${_oldIFS}";

  return ${rescode};
}

# Checks whether given keyword represents a failure.
# -> 1: The keyword.
# <- 0/${TRUE} if the keyword is considered a failure; 1/${FALSE} otherwise.
function isFailureKeyword() {
  local _keyword="${1}";
  local -i rescode=${FALSE};
  local _i;
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in ${FAILURE_KEYWORDS[*]}; do
    if    areEqual "${_i}" "${1}" \
       || areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
                   "$(echo \"${_i}\"       | tr [:upper:] [:lower:] 2> /dev/null)"; then
      rescode=${TRUE};
      break;
    fi;
  done

  if isFalse ${rescode}; then
    for _i in ${BUILTIN_FAILURE_KEYWORDS[*]}; do
      if   areEqual "${_i}" "${1}" \
        || areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
                    "$(echo \"${_i}\"       | tr [:upper:] [:lower:] 2> /dev/null)"; then
        rescode=${TRUE};
        break;
      fi;
    done
  fi
  IFS="${_oldIFS}";

  return ${rescode};
}

