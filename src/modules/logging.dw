# mod: logging
# Logging functions

#export SUCCESS_KEYWORDS;
#export FAILURE_KEYWORDS;

export SUCCESS=0;
export FAILURE=1;
export IN_PROGRESS=2;
export UNDEFINED=255;

if [ -z ${_DRY_WIT_LOG_STACK+x} ]; then
  export _DRY_WIT_LOG_STACK=();
fi

if [ -z ${_DRY_WIT_LOG_CATEGORY_STACK+x} ]; then
  export _DRY_WIT_LOG_CATEGORY_STACK=();
fi

if [ -z ${LOG_CATEGORY_NAMESPACE+x} ]; then
  export LOG_CATEGORY_NAMESPACE="";
fi

if [ -z ${_DRY_WIT_LOG_LEVEL_STACK+x} ]; then
  export _DRY_WIT_LOG_LEVEL_STACK=();
fi

if [ -z ${_DRY_WIT_LOG_TRACE+x} ]; then
  export _DRY_WIT_LOG_TRACE=${FALSE};
fi

if [ -z ${_DRY_WIT_LOG_DEBUG+x} ]; then
  export _DRY_WIT_LOG_DEBUG=${FALSE};
fi

if [ -z ${_DRY_WIT_LOG_INFO+x} ]; then
  export _DRY_WIT_LOG_INFO=${TRUE};
fi

if [ -z ${_DRY_WIT_LOG_OUTCOME_TOKENS+x} ]; then
  export _DRY_WIT_LOG_OUTCOME_TOKENS=();
fi

if [ -z ${_DRY_WIT_LOG_OUTCOME_COLORS+x} ]; then
  export _DRY_WIT_LOG_OUTCOME_COLORS=();
fi

if [ -z ${_DRY_WIT_DEFAULT_TERM_WIDTH+x} ]; then
  export _DRY_WIT_DEFAULT_TERM_WIDTH=80;
fi

if [ -z ${_DRY_WIT_LOG_LINE_OPEN+x} ]; then
  export _DRY_WIT_LOG_LINE_OPEN=${FALSE};
fi

if [ -z ${NESTED_TASK_IN_PROGRESS+x} ]; then
  export NESTED_TASK_IN_PROGRESS="....";
fi

if [ -z ${LOG_TIMESTAMP+x} ]; then
  export LOG_TIMESTAMP="+%Y/%m/%d %H:%M:%S";
fi

if [ -z ${LOG_OUTCOME_SEPARATOR+x} ]; then
  export LOG_OUTCOME_SEPARATOR=" ";
fi

if [ -z ${LOG_NESTED_INDENTATION+x} ]; then
  export LOG_NESTED_INDENTATION="  ";
fi

if [ -z ${_DW_SUCCESS+x} ]; then
  export _DW_SUCCESS="Success";
fi

if [ -z ${_DW_DONE+x} ]; then
  export _DW_DONE="done";
fi

if [ -z ${_DW_OK+x} ]; then
  export _DW_OK="ok";
fi

if [ -z ${SUCCESS+x} ]; then
    export SUCCESS="${_DW_SUCCESS}";
fi
if [ -z ${DONE+x} ]; then
    export DONE="${_DW_DONE}";
fi

if [ -z ${BUILTIN_SUCCESS_KEYWORDS+x} ]; then
  export BUILTIN_SUCCESS_KEYWORDS=(\
    "${_DW_SUCCESS}" \
    "${_DW_DONE}" \
    "${_DW_OK}" \
    );
fi

if [ -z ${_DW_ERROR+x} ]; then
  export _DW_ERROR="Error";
fi

if [ -z ${_DW_FAILURE+x} ]; then
  export _DW_FAILURE="Failure";
fi

if [ -z ${_DW_FAILED+x} ]; then
  export _DW_FAILED="failed";
fi

if [ -z ${_DW_KO+x} ]; then
  export _DW_KO="ko";
fi

if [ -z ${FAILURE+x} ]; then
    export FAILURE="${_DW_FAILURE}";
fi
if [ -z ${FAILED+x} ]; then
    export FAILED="${_DW_FAILED}";
fi

if [ -z ${BUILTIN_FAILURE_KEYWORDS+x} ]; then
  export BUILTIN_FAILURE_KEYWORDS=(\
    "${_DW_ERROR}" \
    "${_DW_FAILURE}" \
    "${_DW_FAILED}" \
    "${_DW_KO}" \
    );
fi

buildColor "NO_COLOR" "0";
buildColor "BLACK" "30" "0";
buildColor "RED" "31" "41";
buildColor "GREEN" "32" "42";
buildColor "YELLOW" "33" "43";
buildColor "BLUE" "34" "44";
buildColor "MAGENTA" "35" "45";
buildColor "CYAN" "36" "46";
buildColor "GRAY" "37" "47";

export SUCCESS_COLOR=GREEN;
export FAILURE_COLOR=RED;
export IN_PROGRESS_COLOR=BLUE;
export UNDEFINED_COLOR=GRAY;
export DEFAULT_LOG_PREFIX_COLOR=GRAY;
export DEFAULT_LOG_OUTCOME_COLOR=GRAY;
export DEFAULT_LOG_RESUMING_TASK_COLOR=GRAY;

export LOG_PREFIX_COLORS=(\
  BLUE   \
  CYAN  \
  YELLOW \
  MAGENTA    \
  YELLOW \
  RED \
  BLUE   \
);

export LOG_PREFIX_TOKENS=(\
    "[" \
    "timestamp"  \
    "<" \
    "category"  \
    ">" \
    "logLevel" \
    "]" \
);
export LOG_PREFIX_TIMESTAMP_POSITION=1;
export LOG_PREFIX_CATEGORY_POSITION=3;
export LOG_PREFIX_LEVEL_POSITION=5;

export INFO_LOG_PREFIX_TOKEN=".";
export DEBUG_LOG_PREFIX_TOKEN="o";
export TRACE_LOG_PREFIX_TOKEN="O";

export LOG_OUTCOME_COLORS=(\
    CYAN  \
    WHITE \
    CYAN  \
);

export LOG_OUTCOME_TOKENS=(\
    "[" \
    "done" \
    "]" \
);

export LOG_OUTCOME_TEXT_POSITION=1;

# txt: Sets the log category namespace.
# txt: Returns 0/TRUE always.
# fun: setLogCategoryNamespace namespace
# opt: namespace: The namespace.
# use: setLogCategoryNamespace "processing"
function setLogCategoryNamespace() {
  export LOG_CATEGORY_NAMESPACE="$1";
}

# txt: Retrieves the log category namespace.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log category namespace.
# fun: getLogCategoryNamespace
# use: getLogCategoryNamespace;
# use: echo "log category namespace: ${RESULT}"
function getLogCategoryNamespace() {
  export RESULT="${LOG_CATEGORY_NAMESPACE}";
}

# txt: Specifies the log category.
# txt: Returns 0/TRUE always.
# fun: setLogCategory
# use: setLogCategory
function setLogCategory() {
  export LOG_CATEGORY="$1";
}

# txt: Retrieves the log category.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log category.
# fun: getLogCategory
# use: getLogCategory;
# use: echo "Log category: ${RESULT}";
function getLogCategory() {
  export RESULT="${LOG_CATEGORY}";
}

# txt: Guesses the type of keyword associated to given text.
# txt: Returns SUCCESS, FAILURE, or UNDEFINED.
# fun: findOutKeyword text
# opt: text: The text of the keyword.
# use: findOutKeyword "done";
# use: local -i keyword=$?;
function findOutKeyword() {
  local _value="${1}";
  local -i result;

  case "${_value}" in
    "${_DW_SUCCESS}") result=${SUCCESS};
               ;;
    "${_DW_FAILURE}") result=${FAILURE};
               ;;
    *) if isSuccessKeyword "${_value}"; then
         result=${SUCCESS};
       elif isFailureKeyword "${_value}"; then
         result=${FAILURE};
       else
         result=${UNDEFINED};
       fi
       ;;
  esac

  return ${result};
}

# txt: Checks whether given tag is defined.
# txt: 0/TRUE if the tag is defined; 1/FALSE otherwise.
# fun: definedTag tag
# opt: tag: The tag to check.
# use: definedTag SUCCESS
function definedTag() {
  local result;

  case "${1}" in
    "${_DW_SUCCESS}" | "${_DW_FAILURE}") result=${TRUE};
       ;;
    *) result=${FALSE};
       ;;
  esac

  return ${result};
}

# txt: Retrieves the verbosity flag.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains '-vv' if trace is enabled; '-v' if debug is enabled; empty string otherwise.
# fun: resolveVerbosity
# use: resolveVerbosity
function resolveVerbosity() {
  local result="";

  if isTraceEnabled; then
      result="-vv";
  elif isDebugEnabled; then
      result="-v";
  elif isInfoEnabled; then
      result="";
  fi;

  export RESULT="${result}";
}

# txt: Checks whether trace is enabled.
# txt: Returns 0/TRUE if trace is enabled; 1/FALSE otherwise.
# fun: isTraceEnabled
# use: isTraceEnabled
function isTraceEnabled() {
  local -i rescode=${FALSE};

  if isDebugEnabled; then
    if isTrue ${_DRY_WIT_LOG_TRACE}; then
      rescode=${TRUE};
    fi
  fi

  return ${rescode};
}

# txt: Enables the trace level.
# txt: Returns 0/TRUE always.
# fun: setTraceEnabled
# use: setTraceEnabled;
function setTraceEnabled() {
  _DRY_WIT_LOG_TRACE=${TRUE};
  setDebugEnabled;
}

# txt: Logs given message under the "trace" level.
# txt: Returns 0/TRUE always.
# fun: logTrace message
# opt: message: The message to log.
# use: logTrace "Operation in progress";
function logTrace() {
  if isTraceEnabled; then
      checkNotEmpty "message" "${1}" 1;
      LOGGING.logStuff TRACE "$@";
  fi
}

# txt: Logs given text as a log result, under the "trace" level.
# txt: Returns 0/TRUE always.
# fun: logTraceResult keyword message
# opt: keyword: The keyword.
# opt: message: The result message to log.
# use: logTraceResult SUCCESS "Operation completed"
function logTraceResult() {
  local _outcome="${1}";
  shift;
  local _message="${@}";

  if isTraceEnabled; then
      checkNotEmpty "outcome" "${_outcome}" 1;
      checkNotEmpty "message" "${_message}" 2;
      LOGGING.logStuffResult TRACE "${_outcome}" "${_message}";
  fi
}

# txt: Logs the contents of given file, under the "trace" level.
# txt: Returns 0/TRUE always.
# fun: logTraceFile file
# opt: file: The file to log.
# use: logTraceFile /tmp/my-log.txt
function logTraceFile() {
  if isTraceEnabled; then
      checkNotEmpty "file" "${1}" 1;
      cat "${1}" 2> /dev/null | while IFS='' read -r line; do LOGGING.logStuff TRACE "${line}"; done
  fi
}

# txt: Checks whether the debug level is enabled.
# txt: Returns 0/TRUE if debug is allowed; 1/FALSE otherwise.
# fun: isDebugEnabled
# use: isDebugEnabled;
function isDebugEnabled() {
  local -i rescode=${FALSE};

  if isInfoEnabled; then
    if isTrue ${_DRY_WIT_LOG_DEBUG}; then
      rescode=${TRUE};
    fi
  fi

  return ${rescode};
}

# txt: Enables the debug level.
# txt: Returns 0/TRUE always.
# fun: setDebugEnabled
# use: setDebugEnabled
function setDebugEnabled() {
  _DRY_WIT_LOG_DEBUG=${TRUE};
  setInfoEnabled;
}

# txt: Logs the contents of given file, under the "debug" level.
# txt: Returns 0/TRUE always.
# fun: logDebugFile file
# opt: file: The file to log.
# use: logDebugFile '/tmp/my-log.txt';
function logDebugFile() {
  if isDebugEnabled; then
      checkNotEmpty "file" "${1}" 1;
      cat "${1}" | while IFS='' read -r line; do LOGGING.logStuff DEBUG "${line}"; done
  fi
}

# txt: Logs given message under the "debug" level.
# txt: Returns 0/TRUE always.
# fun: logDebug message
# opt: message: The message to log.
# use: logDebug "Operation in progress";
function logDebug() {
  if isDebugEnabled; then
      checkNotEmpty "message" "${1}" 1;
      LOGGING.logStuff DEBUG "$@";
  fi
}

# txt: Logs given outcome under the "debug" level.
# txt: Returns 0/TRUE always.
# fun: logDebugResult SUCCESS|FAILURE message
# opt: SUCCESS|FAILURE: The keyword.
# opt: message: The outcome to log.
# use: logDebugResult SUCCESS "done";
function logDebugResult() {
  local _outcome="${1}";
  shift;
  local _message="${@}";

  if isDebugEnabled; then
      checkNotEmpty "outcome" "${_outcome}" 1;
      checkNotEmpty "message" "${_message}" 2;
      LOGGING.logStuffResult DEBUG "${_outcome}" "${_message}";
  fi
}

# txt: Checks whether the enabled log level is lower than "info".
# txt: Returns 0/TRUE in such case; 1/FALSE otherwise.
# fun: isLowerThanInfoEnabled
# use: if isLowerThanInfoEnabled; then ...; fi
function isLowerThanInfoEnabled() {
  if isDebugEnabled || isTraceEnabled; then
    return ${TRUE};
  else
    return ${FALSE};
  fi
}

# txt: Checks whether the "info" level is enabled.
# txt: Returns 0/TRUE in such case; 1/FALSE otherwise.
# fun: isInfoEnabled
# use: if isInfoEnabled; then ...; fi
function isInfoEnabled() {
  local -i rescode=${TRUE};

  if isQuietMode; then
    rescode=${FALSE};
  fi

  return ${rescode};
}

# txt: Enables the "info" level.
# txt: Returns 0/TRUE always.
# fun: setInfoEnabled
# use: setInfoEnabled;
function setInfoEnabled() {
  _DRY_WIT_LOG_QUIET=${FALSE};
}

# txt: Logs the contents of a file as "info".
# txt: Returns 0/TRUE always.
# fun: logInfoFile file
# opt: file: The file containing the text to log.
# use: logInfoFile /tmp/my-log.txt
function logInfoFile() {
  if isInfoEnabled; then
      checkNotEmpty "file" "${1}" 1;
      cat "${1}" | while IFS='' read -r line; do LOGGING.logStuff INFO "${line}"; done
  fi
}

# txt: Logs a message as "info".
# txt: Returns 0/TRUE always.
# fun: logInfo message
# opt: message: The message to log.
# use: logInfo "Operation in progress"
function logInfo() {
  if isInfoEnabled; then
      checkNotEmpty "message" "${1}" 1;
      LOGGING.logStuff INFO "$@";
  fi
}

# txt: Logs the outcome of an operation as "info"
# txt: Returns 0/TRUE always.
# fun: logInfoResult SUCCESS|FAILURE message
# opt: SUCCESS|FAILURE: The outcome.
# opt: message: The message to log.
# use: logInfoResult SUCCESS "done";
function logInfoResult() {
  local _outcome="${1}";
  shift;
  local _message="${@}";

  if isInfoEnabled; then
    checkNotEmpty "outcome" "${_outcome}" 1;
    checkNotEmpty "message" "${_message}" 2;
    LOGGING.logStuffResult INFO "${_outcome}" "${_message}";
  fi
}

# txt: Sets the quiet mode on or off.
# txt: Returns 0/TRUE always.
# fun: setQuietMode mode
# opt: mode: The mode (0/TRUE or 1/FALSE).
# use: setQuietMode ${TRUE};
function setQuietMode() {
  local _mode="${1}";

  checkNotEmpty "mode" "${_mode}" 1;

  _DRY_WIT_LOG_QUIET=${_mode};
}

# txt: Retrieves whether the quiet mode is on or off.
# txt: Returns 0/TRUE if the mode is enabled; 1/FALSE otherwise.
# fun: isQuietMode
# use: if isQuietMode; then ...; fi
function isQuietMode() {
  local -i _rescode;

  if isTrue ${_DRY_WIT_LOG_QUIET}; then
      _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# txt: Enables quiet mode.
# txt: Returns 0/TRUE always.
# fun: enableQuietMode
# use: enableQuietMode;
function enableQuietMode() {
  setQuietMode ${TRUE};
}

# txt: Disables quiet mode.
# txt: Returns 0/TRUE always.
# fun: disableQuietMode
# use: disableQuietMode;
function disableQuietMode() {
  setQuietMode ${FALSE};
}

# txt: Logs a message as "info".
# fun: log message
# opt: message: The message to log.
# use: log "Operation in progress";
function log() {
  checkNotEmpty "message" "${1}" 1;
  _logInfo "$@";
}

# txt: Logs the outcome of an operation, as "info".
# txt: Returns 0/TRUE always.
# fun: logResult SUCCESS|FAILURE message
# opt: SUCCESS|FAILURE: The outcome.
# opt: message: The message.
# use: logResult SUCCESS "done"
function logResult() {
  local _outcome="${1}";
  shift;
  local _message="${@}";

  logInfoResult "${_outcome}" "${_message}";
}

# txt: Logs the contents of a file, as "info".
# fun: logFile file
# opt: file: The file with the log messages.
# use: logFile /tmp/my-log.txt
function logFile() {
  checkNotEmpty "file" "${1}" 1;
  cat "${1}" | while IFS='' read -r line; do LOGGING.logStuff INFO "${line}"; done
}

# txt: Main logging logic.
# txt: Returns 0/TRUE always.
# fun: LOGGING.logStuff level [-n]? message
# opt: level: The logging level.
# opt: -n: Whether to use a new line character at the end or not.
# opt: message: The message to log.
# use: LOGGING.logStuff INFO -n "Operation in progress";
function LOGGING.logStuff() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;
  local _minusN="${1}";
  if [ "-n" == "${_minusN}" ]; then
    shift;
  fi
  LOGGING.logInProgress "${_level}" "$@";
  if [ "-n" != "${_minusN}" ]; then
    echo;
    LOGGING.popLog;
    LOGGING.popLogCategory;
  fi
}

# txt: Logs the outcome of an operation.
# txt: Returns 0/TRUE always.
# fun: LOGGING.logStuffResult level SUCCESS|FAILURE message
# opt: level: The log level.
# opt: SUCCESS|FAILURE: The outcome.
# opt: message: The message.
# use: LOGGING.logStuffResult INFO SUCCESS "done";
function LOGGING.logStuffResult() {
  local _level="${1}";
  local _outcome="${2}";

  checkNotEmpty "level" "${_level}" 1;
  shift;

  checkNotEmpty "outcome" "${_outcome}" 2;
  shift;

  checkNotEmpty "text" "${@}" 3;

  local -i _nestedTasks;
  LOGGING.numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if isZero ${_nestedTasks}; then
      exitWithErrorCode UNACCEPTABLE_API_CALL "No ongoing process to print the outcome for. Review ${FUNCNAME[2]}";
  fi
  LOGGING.logCompleted "${_level}" "${_outcome}" "$@";
}

# txt: Annotates the last log message.
# txt: Returns 0/TRUE always.
# fun: LOGGING.setLastLog message
# opt: message: The message.
# api: internal
# use: LOGGING.setLastLog "Operation in progress";
function LOGGING.setLastLog() {
  _DRY_WIT_LAST_LOG="${@}";
}

# txt: Retrieves the last log message.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the last log message.
# fun: LOGGING.getLastLog
# api: internal
# use: LOGGING.getLastLog;
# use: echo "Last log: ${RESULT}";
function LOGGING.getLastLog() {
  export RESULT="${_DRY_WIT_LAST_LOG}";
}

# txt: Pushes given message to the log stack.
# txt: Returns 0/TRUE always.
# fun: LOGGING.pushLog message
# opt: message: The message to push.
# api: internal
# use: LOGGING.pushLog "Operation in progress"
function LOGGING.pushLog() {
  _DRY_WIT_LOG_STACK[${#_DRY_WIT_LOG_STACK[@]}]="$*";
}

# txt: Pushes given category to the log category stack.
# txt: Returns 0/TRUE always.
# fun: LOGGING.pushLogCategory category
# opt: category: The category to push.
# api: internal
# use: LOGGING.pushLogCategory "sending-data"
function LOGGING.pushLogCategory() {
  _DRY_WIT_LOG_CATEGORY_STACK[${#_DRY_WIT_LOG_CATEGORY_STACK[@]}]="$*";
}

# txt: Pushes given level to the log level stack.
# txt: Returns 0/TRUE always.
# fun: LOGGING.pushLogLevel level
# opt: level: The level to push.
# api: internal
# use: LOGGING.pushLogLevel INFO
function LOGGING.pushLogLevel() {
  _DRY_WIT_LOG_LEVEL_STACK[${#_DRY_WIT_LOG_LEVEL_STACK[@]}]="$*";
}

# txt: Retrieves the number of "in-progress" tasks pending.
# txt: Returns such count.
# fun: LOGGING.numberOfNestedInProgressTasks
# api: internal
# use: LOGGING.numberOfNestedInProgressTasks; local count=$?;
function LOGGING.numberOfNestedInProgressTasks() {
  local -i rescode;
  rescode=${#_DRY_WIT_LOG_STACK[@]};
  return ${rescode};
}

# txt: Pops given message from the log stack.
# txt: Returns 0/TRUE if the stack contained at least the popped item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the popped message.
# fun: LOGGING.popLog
# api: internal
# use: if LOGGING.popLog; then echo "Last log: ${RESULT}"; fi
function LOGGING.popLog() {
  local -i rescode;
  local result="";
  local -i _len=${#_DRY_WIT_LOG_STACK[@]};
  local -i _newLen;
  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    result="${_DRY_WIT_LOG_STACK[${_newLen}]}";
    eval "unset _DRY_WIT_LOG_STACK[${_newLen}]";
    rescode=$?;
  else
    rescode=${FALSE};
  fi
  if isTrue ${rescode}; then
      export RESULT="${result}";
  fi
  return ${rescode};
}

# txt: Peeks given message from top of the log stack.
# txt: Returns 0/TRUE if the stack contains at least the returned item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the message.
# fun: LOGGING.peekLog
# api: internal
# use: if LOGGING.peekLog; then echo "Last log: ${RESULT}"; fi
function LOGGING.peekLog() {
  local -i rescode;
  local result="";
  local -i _len=${#_DRY_WIT_LOG_STACK[@]};
  local -i _newLen;
  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    result="${_DRY_WIT_LOG_STACK[${_newLen}]}";
    rescode=$?;
  else
    rescode=1;
  fi
  if isTrue ${rescode}; then
      export RESULT="${result}";
  fi
  return ${rescode};
}

# txt: Pops given category from the log category stack.
# txt: 0/TRUE if the stack contained at least the popped item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the popped category.
# fun: LOGGING.popLogCategory
# api: internal
# use: if LOGGING.popLogCategory; then echo "Last log category: ${RESULT}"; fi
function LOGGING.popLogCategory() {
  local -i rescode;
  local -i _len=${#_DRY_WIT_LOG_CATEGORY_STACK[@]};
  local -i _newLen;
  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    export RESULT="${_DRY_WIT_LOG_CATEGORY_STACK[${_newLen}]}";
    eval "unset _DRY_WIT_LOG_CATEGORY_STACK[${_newLen}]";
    rescode=$?;
  else
    rescode=${FALSE};
  fi
  return ${rescode};
}

# txt: Peeks given category from the log category stack.
# txt: Returns 0/TRUE if the stack contained at least the returned item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the category.
# fun: LOGGING.peekLogCategory
# api: internal
# use: if LOGGING.peekLogCategory; then echo "Last log category: ${RESULT}"; fi
function LOGGING.peekLogCategory() {
  local -i rescode;
  local result="";
  local -i _len=${#_DRY_WIT_LOG_CATEGORY_STACK[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    result="${_DRY_WIT_LOG_CATEGORY_STACK[${_newLen}]}";
    rescode=$?;
  else
    rescode=${FALSE};
  fi

  if isTrue ${rescode}; then
      export RESULT="${result}";
  fi
  return ${rescode};
}

# txt: Pops given level from the log level stack.
# txt: Returns 0/TRUE if the stack contained at least the popped item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the popped level.
# fun: LOGGING.popLogLevel
# api: internal
# use: if LOGGING.popLogLevel; then echo "Last log level: ${RESULT}"; fi
function LOGGING.popLogLevel() {
  local -i rescode;
  local -i _len=${#_DRY_WIT_LOG_LEVEL_STACK[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    export RESULT="${_DRY_WIT_LOG_LEVEL_STACK[${_newLen}]}";
    eval "unset _DRY_WIT_LOG_LEVEL_STACK[${_newLen}]";
    rescode=$?;
  else
    rescode=${FALSE};
  fi

  return ${rescode};
}

## PRIVATE
## Peeks given level from the log level stack.
## <- 0: if the stack contained at least the returned item; 1 otherwise.
## <- RESULT: The level.
## Example:
##   if LOGGING.peekLogLevel; then
##     echo "Last log level: ${RESULT}";
##   fi
function LOGGING.peekLogLevel() {
  local -i rescode;
  local result="";
  local -i _len=${#_DRY_WIT_LOG_LEVEL_STACK[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    result="${_DRY_WIT_LOG_LEVEL_STACK[${_newLen}]}";
    rescode=$?;
  else
    rescode=${FALSE};
  fi

  if isTrue ${rescode}; then
      export RESULT="${result}";
  fi
  return ${rescode};
}

# txt: Checks whether the log line is currently opened.
# txt: Returns 0/TRUE if it's open; 1/FALSE otherwise.
# fun: LOGGING.isLogLineOpen
# api: internal
# use: if LOGGING.isLogLineOpen; then [..]; fi
function LOGGING.isLogLineOpen() {
  return ${_DRY_WIT_LOG_LINE_OPEN};
}

# txt: Opens the log line.
# txt: Returns 0/TRUE always.
# fun: LOGGING.openLogLine
# api: internal
# use: LOGGING.openLogLine;
function LOGGING.openLogLine() {
  export _DRY_WIT_LOG_LINE_OPEN=${TRUE};
}

# txt: Closes the log line.
# txt: Returns 0/TRUE always.
# fun: LOGGING.closeLogLine
# use: LOGGING.closeLogLine;
function LOGGING.closeLogLine() {
  export _DRY_WIT_LOG_LINE_OPEN=${FALSE};
}

# txt: Retrieves the timestamp used for logging.
# txt: Override LOG_TIMESTAMP to modify the timestamp format.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the timestamp.
# fun: LOGGING.retrieveLogTimestamp
# api: internal
# use: LOGGING.retrieveLogTimestamp; echo "The log timestamp is ${RESULT}";
function LOGGING.retrieveLogTimestamp() {
  export RESULT="$(date "${LOG_TIMESTAMP}")";
}

# txt: Retrieves the position of the timestamp in the log prefix tokens array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the timestamp position.
# fun: LOGGING.retrieveTimestampPositionInLogPrefix
# api: internal
# use: LOGGING.retrieveTimestampPositionInLogPrefix; echo "timestamp -> ${RESULT}";
function LOGGING.retrieveTimestampPositionInLogPrefix() {
  export RESULT=${LOG_PREFIX_TIMESTAMP_POSITION};
}

# txt: Retrieves the position of the category in the log prefix tokens array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the category position.
# fun: LOGGING.retrieveCategoryPositionInLogPrefix
# api: internal
# use: LOGGING.retrieveCategoryPositionInLogPrefix; echo "category -> ${RESULT}";
function LOGGING.retrieveCategoryPositionInLogPrefix() {
  export RESULT=${LOG_PREFIX_CATEGORY_POSITION};
}

# txt: Retrieves the position of the log level in the log prefix tokens array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the level position.
# fun: LOGGING.retrieveLevelPositionInLogPrefix
# api: internal
# use: LOGGING.retrieveLevelPositionInLogPrefix; echo "level -> ${RESULT}";
function LOGGING.retrieveLevelPositionInLogPrefix() {
  export RESULT=${LOG_PREFIX_LEVEL_POSITION};
}

# txt: Retrieves the position of the outcome token in the log outcome colors array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the outcome text position.
# fun: LOGGING.retrieveOutcomeTextPositionInLogOutcome
# api: internal
# use: LOGGING.retrieveOutcomeTextPositionInLogOutcome; echo "outcome text -> ${RESULT}";
function LOGGING.retrieveOutcomeTextPositionInLogOutcome() {
  export RESULT=${LOG_OUTCOME_TEXT_POSITION};
}

# txt: Retrieves the tokens composing the log prefix.
# txt: Returns 0/TRUE always.
# fun: LOGGING.retrieveLogPrefixTokens category level
# opt: category: The log category.
# opt: level: The log level (optional).
# api: internal
# use: LOGGING.retrieveLogPrefixTokens "a:b:c" DEBUG; echo "${_DRY_WIT_LOG_PREFIX_TOKENS[*]}";
function LOGGING.retrieveLogPrefixTokens() {
  local _category="${1}";
  checkNotEmpty "category" "${_category}" 1;

  local _levelVar="${2}";

  evalConstant "${_levelVar}_LOG_PREFIX_TOKEN" "${INFO_LOG_PREFIX_TOKEN}";
  local _level="${RESULT}";
  local result=();
  local _aux="";
  local _timestamp;
  local -i _i;
  local -i _len;
  local -i _timestampPosition;
  local -i _category_position;
  local -i _levelPosition;

  _len=$((${#LOG_PREFIX_TOKENS[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    _DRY_WIT_LOG_PREFIX_TOKENS[${_i}]="${LOG_PREFIX_TOKENS[${_i}]}";
  done
  IFS="${_oldIFS}";

  LOGGING.retrieveLogTimestamp;
  _timestamp="${RESULT}";
  LOGGING.retrieveTimestampPositionInLogPrefix;
  _timestampPosition=${RESULT};
  _DRY_WIT_LOG_PREFIX_TOKENS[${_timestampPosition}]="${_timestamp}";
  LOGGING.retrieveCategoryPositionInLogPrefix;
  _categoryPosition=${RESULT};
  _DRY_WIT_LOG_PREFIX_TOKENS[${_categoryPosition}]="${_category}";
  LOGGING.retrieveLevelPositionInLogPrefix;
  _levelPosition=${RESULT};
  _DRY_WIT_LOG_PREFIX_TOKENS[${_levelPosition}]="${_level}";
}

# txt: Retrieves the tokens composing the log outcome.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the output file to source to be able to use _DRY_WIT_LOG_OUTCOME_TOKENS array.
# fun: LOGGING.retrieveLogOutcomeTokens text
# opt: text: The outcome text.
# api: internal
# use: LOGGING.retrieveLogOutcomeTokens "done"; source ${RESULT}; echo "${_DRY_WIT_LOG_OUTCOME_TOKENS[*]}";
function  LOGGING.retrieveLogOutcomeTokens() {
  local _text="${1}";
  checkNotEmpty "text" "${_text}" 1;

  local result=();
  local _aux="";
  local _timestamp;
  local -i _i;
  local -i _len;
  local -i _outcomeTextPosition;

  _len=$((${#LOG_OUTCOME_TOKENS[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    _DRY_WIT_LOG_OUTCOME_TOKENS[${_i}]="${LOG_OUTCOME_TOKENS[${_i}]}";
  done
  IFS="${_oldIFS}";

  LOGGING.retrieveOutcomeTextPositionInLogOutcome;
  _outcomeTextPosition=${RESULT};
  _DRY_WIT_LOG_OUTCOME_TOKENS[${_outcomeTextPosition}]="${_text}";
}

# txt: Retrieves the tokens composing the log outcome.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the output file to source to be able to use _DRY_WIT_LOG_OUTCOME_COLORS array.
# fun: LOGGING.retrieveLogOutcomeColors SUCCESS|FAILURE|IN_PROGRESS
# opt: SUCCESS|FAILURE|IN_PROGRESS: The keyword (SUCCESS, FAILURE, IN_PROGRESS).
# api: internal
# use: LOGGING.retrieveLogOutcomeColors SUCCESS "done"; source ${RESULT}; echo "${_DRY_WIT_LOG_OUTCOME_COLORS[*]}";
function LOGGING.retrieveLogOutcomeColors() {
  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 1;

  local result=();
  local _aux="";
  _retrieveKeywordColor "${_keyword}";
  local _keywordColor="${RESULT}";
  local -i _i;
  local -i _len;
  local -i _outcomeTextPosition;

  _len=$((${#LOG_OUTCOME_COLORS[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    _DRY_WIT_LOG_OUTCOME_COLORS[${_i}]="${LOG_OUTCOME_COLORS[${_i}]}";
  done
  IFS="${_oldIFS}";

  LOGGING.retrieveOutcomeTextPositionInLogOutcome;
  _outcomeTextPosition=${RESULT};
  _DRY_WIT_LOG_OUTCOME_COLORS[${_outcomeTextPosition}]="${_keywordColor}";
}

# txt: Retrieves the color for a given keyword.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the associated color.
# fun: LOGGING.retrieveKeywordColor SUCCESS|FAILURE|IN_PROGRESS defaultColor
# txt: SUCCESS|FAILURE|IN_PROGRESS: The keyword (SUCCESS, FAILURE, IN_PROGRESS).
# txt: defaultColor: The default color.
# api: internal
# use: LOGGING.retrieveKeywordColor SUCCESS GREEN; echo "Color -> ${RESULT}";
function LOGGING.retrieveKeywordColor() {
  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 1;
  local _defaultColor="${2:-${NO_COLOR}}";

  local result;

  case ${_keyword} in
    SUCCESS | "${SUCCESS}") result="${SUCCESS_COLOR}";
                            ;;
    FAILURE | "${FAILURE}" | "${_DW_FAILURE}" | "${_DW_FAILED}" | "FAILED" | "failed" | "FAIL" | "fail") result="${FAILURE_COLOR}";
                                                                    ;;
    IN_PROGRESS | "${IN_PROGRESS}") result="${IN_PROGRESS_COLOR}";
                                    ;;
    *) result="${_defaultColor}";
       ;;
  esac

  export RESULT="${result}";
}

# txt: Prints the log prefix.
# txt: Returns 0/TRUE always.
# fun: LOGGING.echoLogPrefix category level
# opt: category: The log category.
# opt: level: The log level.
# api: internal
# use: LOGGING.echoLogPrefix "cat" DEBUG
function LOGGING.echoLogPrefix() {
  local _category="${1}";
  checkNotEmpty "category" "${_category}" 1;

  local _level="${2}";
  checkNotEmpty "level" "${_level}" 2;

  local _allowsColors;
  allowsColors;
  _allowsColors=$?;
  LOGGING.echoColorAwareLogPrefix "${_category}" ${_allowsColors} "${_level}";
}

# txt: Retrieves the log prefix.
# txt: Returns 0/TRUE always.
# fun: LOGGING.retrieveLogPrefix category level
# opt: category: The log category.
# opt: level: The log level.
# api: internal
# use: LOGGING.retrieveLogPrefix "cat" DEBUG; echo "log prefix -> ${RESULT}";
function LOGGING.retrieveLogPrefix() {
  local _category="${1}";
  checkNotEmpty "category" "${_category}" 1;

  local _level="${2}";
  checkNotEmpty "level" "${_level}" 2;

  local result="$(_echoColorAwareLogPrefix "${_category}" ${FALSE} "${_level}")";
  export RESULT="${result}";
}

# txt: Prints the log prefix, for color terminals.
# txt: Returns 0/TRUE always.
# fun: LOGGING.echoColorAwareLogPrefix category TRUE|FALSE level
# opt: category: The log category.
# opt: TRUE|FALSE: ${TRUE} if using colors; ${FALSE} otherwise.
# opt: level: The log level.
# api: internal
# use: LOGGING.echoColorAwareLogPrefix "cat" ${TRUE} DEBUG
function LOGGING.echoColorAwareLogPrefix() {
  local _category="${1}";
  checkNotEmpty "category" "${_category}" 1;

  local -i _allowsColors=${2};
  checkNotEmpty "allowsColors" "${_allowsColors}" 2;

  local _level="${3}";
  checkNotEmpty "level" "${_level}" 3;

  local _len;
  local _colors;
  local -i _i;

  LOGGING.retrieveLogPrefixTokens "${_category}" "${_level}";

  _len=$((${#_DRY_WIT_LOG_PREFIX_TOKENS[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    if isTrue ${_allowsColors}; then
      echoInColor -n "${LOG_PREFIX_COLORS[${_i}]}" "${_DRY_WIT_LOG_PREFIX_TOKENS[${_i}]}";
    else
      echo -n "${_DRY_WIT_LOG_PREFIX_TOKENS[${_i}]}";
    fi
  done
  IFS="${_oldIFS}";

  if isTrue ${_allowsColors}; then
    resetColor;
  fi
  echo -n " ";
}

# txt: Retrieves the log namespace.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log namespace.
# fun: LOGGING.retrieveLogNamespace
# api: internal
# use: LOGGING.retrieveLogNamespace; echo "namespace: ${RESULT}";
function LOGGING.retrieveLogNamespace() {
  local _namespace="${LOG_CATEGORY_NAMESPACE}";
  local _category="${LOG_CATEGORY}";
  local result;

  if isEmpty "${_namespace}"; then
    if isEmpty "${SCRIPT_NAME}" ; then
      result="?";
    else
      result="$(basename ${SCRIPT_NAME} .sh)";
    fi
  fi

  if isNotEmpty ${_category} ; then
    result="${result}:${_category}";
  fi

  export RESULT="${result}";
}

# txt: Prints the log outcome.
# txt: Returns 0/TRUE always.
# fun: LOGGING.echoLogOutcome level SUCCESS|FAILURE|IN_PROGRESS text
# opt: level: The log level.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The keyword  (SUCCESS, FAILURE, IN_PROGRESS).
# opt: text: The outcome text.
# api: internal
# use: LOGGING.echoLogOutcome DEBUG SUCCESS "sample"
function LOGGING.echoLogOutcome() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift;

  local _text="${@}";
  local _len;
  local _allowsColors;
  local _colors;
  local _inProgressMessage;
  local _logPrefix;
  local -i i;

  LOGGING.retrieveLogOutcomeTokens "${_text}";

  allowsColors;
  _allowsColors=$?;

  if isTrue ${_allowsColors}; then
    LOGGING.retrieveLogOutcomeColors ${_keyword};
  fi

  LOGGING.peekLog;
  _inProgressMessage="${RESULT}";
  LOGGING.peekLogCategory;
  _category="${RESULT}";
  if isEmpty "${_category}"; then
    exitWithErrorCode POSTCONDITION_NOT_SATISFIED "_peekLogCaterory must not return an empty string";
  fi
  LOGGING.peekLogLevel;
  _level="${RESULT}";
  LOGGING.retrieveLogPrefix "${_category}" "${_level}";
  _logPrefix="${RESULT}";
  LOGGING.alignRight "${_logPrefix}${_inProgressMessage}" "${_text}";

  _len=$((${#_DRY_WIT_LOG_OUTCOME_TOKENS[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    if isTrue ${_allowsColors}; then
      echoInColor -n "${_DRY_WIT_LOG_OUTCOME_COLORS[${_i}]}" "${_DRY_WIT_LOG_OUTCOME_TOKENS[${_i}]}";
    else
      echo -n "${_DRY_WIT_LOG_OUTCOME_TOKENS[${_i}]}";
    fi
  done
  IFS="${_oldIFS}";

  if isTrue ${_allowsColors}; then
    resetColor;
  fi
}

# txt: Prints the log outcome, used when nesting log calls.
# txt: Returns 0/TRUE always.
# fun: LOGGING.echoLogOutcomeNested level SUCCESS|FAILURE|IN_PROGRESS text
# opt: level: The log level.
# opt: SUCCESS_FAILURE_IN_PROGRESS: The keyword  (SUCCESS, FAILURE, IN_PROGRESS).
# opt: text: The outcome text.
# api: internal
# use: LOGGING.echoLogOutcome DEBUG SUCCESS "sample"
function LOGGING.echoLogOutcomeNested() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift;

  local _text="${@}";
  local _inProgressMessage;
  local _alreadyInProgressMessage;
  local _category;
  local _alreadyInProgressCategory;
  local _indentation;
  local -i _i;
  LOGGING.popLog;
  _inProgressMessage="${RESULT}";
  LOGGING.popLogCategory;
  _category="${RESULT}";
  LOGGING.echoLogOutcome "${_level}" "${_keyword}" "${_text}";
  LOGGING.numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 1 ${_nestedTasks}); do
    _indentation="${_indentation}${LOG_NESTED_INDENTATION}";
  done
  IFS="${_oldIFS}";
  LOGGING.pushLog "${_indentation}${_inProgressMessage}";
  LOGGING.pushLogCategory "${_category}";
}

# txt: Writes spaces until the next message to print is aligned to the right.
# txt: Returns 0/TRUE always.
# fun: LOGGING.alignRight message outcome
# opt: message: The log-line message.
# opt: outcome: The log outcome message.
# api: internal
# use: LOGGING.alignRight "Finishing work" "done";
function LOGGING.alignRight() {
  local _logLineMessage="${1}";
  checkNotEmpty "message" "${_logLineMessage}" 1;

  local _outcome="${2}";
  checkNotEmpty "outcome" "${_outcome}" 2;

  local _logMessage;

  local -i _termWidth;
  local -i _index;
  local -i _offset=0;
  local -i _end;
  local _allowsColors;
  local _token;

  LOGGING.retrieveLogOutcomeTokens "${_outcome}";
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _token in "${_DRY_WIT_LOG_OUTCOME_TOKENS[@]}"; do
    _logMessage="${_logMessage}${_token}";
  done
  IFS="${_oldIFS}";

  getTermWidth;
  if isTrue $?; then
    _termWidth=${RESULT};
    if [ ${_termWidth} -le 0 ]; then
      exitWithErrorCode POSTCONDITION_NOT_SATISFIED "getTermWidth() must not return successfully providing 0 as output";
    fi
    _index=0;
    allowsColors;
    _allowsColors=$?;
    if isTrue ${_allowsColors}; then
      _offset=$((_offset));
    fi
    _end=$((${_offset}+${_termWidth}-${#_logLineMessage}%${_termWidth}-${#_logMessage}-1));
    while [ $((_end)) -lt 0 ]; do
      echo "";
      _end=$((-${_end}+${_offset}+${_termWidth}-${#_logMessage}));
    done
    while [ $((${_end}-${_index}+1)) != 0 ]; do
      _index=$((${_index}+1));
      echo -n "${LOG_OUTCOME_SEPARATOR}";
    done
  fi
}

# txt: Prints a log message.
# txt: Returns 0/TRUE always.
# fun: LOGGING.logMessage level message
# opt: level: The log level.
# opt: message: The message.
# api: internal
# use: LOGGING.logMessage INFO "A message to log"
function LOGGING.logMessage() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;

  shift;
  local _message="$@";
  checkNotEmpty "message" "${_message}" 2;
  LOGGING.logInProgress "${_level}" "${_message}";
  echo;
}

# txt: Prints a log message, indicating some uncompleted task.
# txt: Returns 0/TRUE always.
# fun: LOGGING.logInProgress level message
# opt: level: The log level.
# opt: message: The message.
# api: internal
# use: LOGGING.logInProgress INFO "Calculating ...";
function LOGGING.logInProgress() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _message="$@";
  checkNotEmpty "message" "${_message}" 2;

  local -i nestedTasks;
  local _category;
  LOGGING.retrieveLogNamespace;
  _category="${RESULT}";

  LOGGING.numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if [ ${_nestedTasks} -gt 0 ]; then
      LOGGING.logInProgressNested "${_category}" "${_level}" "${_message}";
  else
    LOGGING.logInProgressNoNested "${_category}" "${_level}" "${_message}";
  fi
}

# txt: Prints a log message, indicating some uncompleted task, when there're nested tasks.
# txt: Returns 0/TRUE always.
# fun: LOGGING.logInProgressNested category level message
# opt: category: The category.
# opt: level: The log level.
# opt: message: The message.
# api: internal
# use: LOGGING.logInProgressNested "cat" DEBUG "Calculating ...";
function LOGGING.logInProgressNested() {
  local _category="${1}";
  checkNotEmpty "category" "${_category}" 1;
  shift;

  local _level="${1}";
  checkNotEmpty "level" "${_level}" 2;
  shift;

  local _message="$@";
  checkNotEmpty "message" "${_message}" 3;

  local _logPrefix;
  LOGGING.pushLog "${_message}";
  LOGGING.pushLogCategory "${_category}";
  LOGGING.pushLogLevel "${_level}";
  LOGGING.logCompletedNestedNoPop "${_level}" IN_PROGRESS "${NESTED_TASK_IN_PROGRESS}";
  echo;

  LOGGING.retrieveLogPrefix "${_category}" "${_level}";
  _logPrefix="${RESULT}";
  LOGGING.echoLogPrefix "${_category}" "${_level}";
  LOGGING.peekLog;
  _actualMessage="${RESULT}";
  echoColorizedText "${_actualMessage}" "" "${DEFAULT_LOG_PREFIX_COLOR}";
}

# txt: Prints a log message, indicating some uncompleted task, when there're no nested tasks.
# txt: Returns 0/TRUE always.
# fun: LOGGING.logInProgressNoNested category level message
# opt: category: The log category.
# opt: level: The log level.
# opt: message: The message.
# api: internal
# use: LOGGING.logProgressNoNested "cat" INFO "Calculating ...";
function LOGGING.logInProgressNoNested() {
  local _category="${1}";
  checkNotEmpty "category" "${_category}" 1;
  shift;

  local _level="${1}";
  checkNotEmpty "level" "${_level}" 2;
  shift;

  local _message="$@";
  checkNotEmpty "message" "${_message}" 3;
  local _logPrefix;

  _logPrefix="${RESULT}";
  LOGGING.pushLogCategory "${_category}";
  LOGGING.pushLog "${_message}";
  LOGGING.pushLogLevel "${_level}";
  LOGGING.echoLogPrefix "${_category}" "${_level}";
  echoColorizedText "${_message}" "" "${DEFAULT_LOG_PREFIX_COLOR}";
}


# txt: Prints the result of a task.
# txt: Returns 0/TRUE always.
# fun: LOGGING.logCompleted level SUCCESS|FAILURE|IN_PROGRESS outcome
# opt: level: The log level.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS).
# opt: outcome: The outcome text.
# api: internal
# use: LOGGING.logCompleted INFO SUCCESS "done";
function LOGGING.logCompleted() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift;
  local _text="${@}";
  checkNotEmpty "text" "${_text}" 3;

  local -i nestedTasks;

  LOGGING.numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if [ ${_nestedTasks} -gt 1 ]; then
    LOGGING.logCompletedNested "${_level}" "${_keyword}" "${_text}";
  else
    LOGGING.logCompletedNoNested "${_level}" "${_keyword}" "${_text}";
  fi
}

# txt: Prints the result of a task.
# txt: Returns 0/TRUE always.
# fun: LOGGING.logCompletedNoNested level SUCCESS|FAILURE|IN_PROGRESS outcome
# opt: level: The log level.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS).
# opt: outcome: The outcome text.
# api: internal
# use: LOGGING.logCompletedNoNested INFO SUCCESS "done";
function LOGGING.logCompletedNoNested() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift;

  local _text="${@}";
  checkNotEmpty "outcome" "${_text}" 3;

  LOGGING.echoLogOutcome "${_level}" "${_keyword}" "${_text}";
  LOGGING.popLog;
  LOGGING.popLogCategory;
  LOGGING.popLogLevel;
  echo;
}

# txt: Prints the result of a task, when there're nested tasks.
# txt: Returns 0/TRUE always.
# fun: LOGGING.logCompletedNested level SUCCESS|FAILURE|IN_PROGRESS outcome
# opt: level: The log level.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS).
# opt: outcome: The outcome text.
# api: internal
# use: LOGGING.logCompletedNested INFO SUCCESS "done";
function LOGGING.logCompletedNested() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift

  local _message="$@";
  checkNotEmpty "outcome" "${_message}" 3;

  local _nestedTask;
  local _nestedTaskCategory;
  local _logPrefix;
  LOGGING.echoLogOutcome "${_level}" "${_keyword}" "${_message}";
  echo;
  LOGGING.popLogCategory;
  LOGGING.peekLogCategory;
  _nestedTaskCategory="${RESULT}";
  LOGGING.popLogLevel;
  LOGGING.peekLogLevel;
  _nestedTaskLevel="${RESULT}";
  LOGGING.popLog;
  LOGGING.peekLog;
  _nestedTask="${RESULT}";
  LOGGING.echoLogPrefix "${_nestedTaskCategory}" "${_nestedTaskLevel}";
  echoColorizedText "${_nestedTask}" "" "${DEFAULT_LOG_RESUMING_TASK_COLOR}";
}

# txt: Prints the result of a task, when there're nested tasks.
# txt: Returns 0/TRUE always.
# fun: LOGGING.logCompletedNestedNoPop level SUCCESS|FAILURE|IN_PROGRESS outcome
# opt: level: The log level.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS);
# opt: outcome: The outcome text.
# api: internal
# use: LOGGING.logCompletedNested SUCCESS "done";
function LOGGING.logCompletedNestedNoPop() {
  local _level="${1}";
  checkNotEmpty "level" "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty "keyword" "${_keyword}" 2;
  shift
  local _message="$@";
  checkNotEmpty "message" "${_message}" 3;

  LOGGING.echoLogOutcomeNested "${_level}" "${_keyword}" "${_message}";
}

# txt: Logs the contents of a file, using the DEBUG level.
# txt: Returns 0/TRUE always.
# fun: logDebugFileContents file
# opt: file: The file.
# use: logDebugFileContents /tmp/my-file.log
function logDebugFileContents() {
  if isDebugEnabled; then
    [ -f "$1" ] && sed 's ^\s+$  g' "$1" | awk '{printf("logDebug \"%s\"\n", $0);}' | sh
  fi
}

# txt: Checks whether given keyword represents a success.
# txt: Returns 0/TRUE if the keyword is considered a success; 1/FALSE otherwise.
# fun: isSuccessKeyword keyword
# opt: keyword: The keyword.
# use: if isSuccessKeyword "${keyword}"; then logInfoResult SUCCESS "done"; fi
function isSuccessKeyword() {
  local _keyword="${1}";
  local -i rescode=${FALSE};
  local _i;
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  if    isNotEmpty "${SUCCESS_KEYWORDS}" \
     && isNotEmpty ${SUCCESS_KEYWORDS[*]}; then
    for _i in ${SUCCESS_KEYWORDS[*]}; do
      if    areEqual "${_i}" "${_keyword}" \
         || areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
                     "$(echo \"${_i}\"       | tr [:upper:] [:lower:] 2> /dev/null)"; then
        rescode=${TRUE};
        break;
      fi;
    done
  fi

  if isFalse ${rescode}; then
    for _i in ${BUILTIN_SUCCESS_KEYWORDS[*]}; do
      if    areEqual "${_i}" "${1}" \
         || areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
                     "$(echo \"${_i}\"       | tr [:upper:] [:lower:] 2> /dev/null)"; then
        rescode=${TRUE};
        break;
      fi;
    done
  fi
  IFS="${_oldIFS}";

  return ${rescode};
}

# txt: Checks whether given keyword represents a failure.
# txt: Returns 0/TRUE if the keyword is considered a failure; 1/FALSE otherwise.
# fun: isFailureKeyword keyword
# opt: keyword: The keyword.
# use: if isFailureKeyword "${keyword}"; then logInfoResult SUCCESS "done"; fi
function isFailureKeyword() {
  local _keyword="${1}";
  local -i rescode=${FALSE};
  local _i;
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in ${FAILURE_KEYWORDS[*]}; do
    if    areEqual "${_i}" "${1}" \
       || areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
                   "$(echo \"${_i}\"       | tr [:upper:] [:lower:] 2> /dev/null)"; then
      rescode=${TRUE};
      break;
    fi;
  done

  if isFalse ${rescode}; then
    for _i in ${BUILTIN_FAILURE_KEYWORDS[*]}; do
      if   areEqual "${_i}" "${1}" \
        || areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
                    "$(echo \"${_i}\"       | tr [:upper:] [:lower:] 2> /dev/null)"; then
        rescode=${TRUE};
        break;
      fi;
    done
  fi
  IFS="${_oldIFS}";

  return ${rescode};
}
#
