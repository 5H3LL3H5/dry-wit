# mod: debug

# txt: Tries to declare a variable with given arguments.
# txt: Returns 0/TRUE always.
# fun: debugVariable varName varValue+
# opt: varName: The variable name.
# opt: varValue: The variable value(s).
# api: debugVariable
# use: debugVariable "foo" "bar";
function debugVariable() {
  local _name="${1}";
  shift;
  local _value="${@}";

  declare -t "${_name}"="${_value}";
#  trap "echo ${_name} is being used here." DEBUG
}

# txt: Prints the contents of given array.
# txt: Returns 0/TRUE always.
# fun: debugArray arrayName
# opt: arrayName: The name of the array.
# api: debugArray
# use: A=( "1" "2" "3" );
# use: debugArray "${A}"
function debugArray() {
  DW.import array;
  flattenArray "${1}" " + ";
  debugEcho "${RESULT}";
}

# txt: Prints the contents of given associative array.
# txt: Returns 0/TRUE always.
# fun: debugAssociativeArray arrayName
# opt: arrayName: The name of the associative array.
# api: debugAssociativeArray
# use: A=( [foo]=bar [other key]="other value" );
# use: debugArray "${A}"
function debugAssociativeArray() {
  local _associativeArrayName="${1}";
  DW.import array;

  checkNotEmpty "associativeArrayName" "${_associativeArrayName}" 1;

  debugEcho "BEGIN processing array ${_associativeArrayName}";

  forEachAssociativeArrayEntryDo "${_associativeArrayName}" debugAssociativeArrayEntry;

  debugEcho "DONE processing array ${_associativeArrayName}";
}

# txt: Callback to be called to debug a specific entry in an associative array.
# txt: Returns 0/TRUE always.
# fun: debugAssociativeArrayEntry key value
# opt: key: The entry key. Mandatory.
# opt: value: The entry value. Could be empty.
# api: debugAssociativeArrayEntry
# use: forEachAssociativeArrayEntryDo MY_ASSOCIATIVE_ARRAY debugAssociativeArrayEntry; done
function debugAssociativeArrayEntry() {
  local _key="${1}";
  local _value="${2}";

  checkNotEmpty "key" "${_key}" 1;

  debugEcho "${_key} -> ${_value}";
}

# txt: Traces the API call to the default log file using in development.
# txt: Returns 0/TRUE always.
# fun: traceApiCall
# api: traceApiCall
# use: traceApiCall
function traceApiCall() {
  local -i _i=0;
  local _logFile;

  DEBUG.getDebugLogFile;
  _logFile="${RESULT}";

  echo "${FUNCNAME[0]}" >> ${_logFile};
  while caller $i >> ${_logFile}; do
    i=$((i+1))
  done
}

# txt: Specifies the log file for debugging purposes.
# txt: Returns 0/TRUE if the log file can be used for writing; 1/FALSE otherwise.
# fun: setDebugLogFile fileName
# opt: fileName: The log file.
# api: setDebugLogFile
# use: setDebugLogFile "/tmp/.dw-debug.log";
function setDebugLogFile() {
  local _file="${1}";
  local -i _rescode=${TRUE};

  if isNotEmpty "${_file}"; then
    mkdir -p "$(dirname "${_file}")";
    touch "${_file}";
    _rescode=$?;
  fi

  if isTrue ${_rescode}; then
    export __DW_DEBUG_LOG_FILE="${_file}";
  fi

  return ${_rescode};
}

# txt: Retrieves the log file for debugging purposes.
# txt: Returns 0/TRUE always, and the variable RESULT contains the path of the debug file.
# fun: DEBUG.getDebugLogFile
# use: DEBUG.getDebugLogFile;
# use: echo "log file -> ${RESULT}";
function DEBUG.getDebugLogFile() {
  export RESULT="${__DW_DEBUG_LOG_FILE}";
}

# txt: Specifies whether "debugEcho" is enabled.
# txt: Returns 0/TRUE always.
# fun: setDebugEchoEnabled bool
# opt: bool: That condition.
# api: setDebugEchoEnabled
# use: setDebugEchoEnabled TRUE
function setDebugEchoEnabled() {
  local _flag="${1}";

  checkNotEmpty "flag" "${_flag}" 1;

  if isTrue "${_flag}"; then
    export __DW_DEBUG_ECHO_ENABLED=${TRUE};
  else
    export __DW_DEBUG_ECHO_ENABLED=${FALSE};
  fi
}

# txt: Retrieves whether "debugEcho" is enabled.
# txt: Returns  0/TRUE if it's enabled; 1/FALSE otherwise.
# fun: isDebugEchoEnabled
# api: isDebugEchoEnabled
# use: if isDebugEchoEnabled; then
# use:   ...
# use: fi
function isDebugEchoEnabled() {
  local -i _rescode;

  if isTrue ${__DW_DEBUG_ECHO_ENABLED}; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# txt: Echoes a line to stdout. Useful for locating them easily when debugging.
# txt: Returns 0/TRUE always.
# fun: debugEcho message
# opt: message: The message to print.
# api: debugEcho
# use: debugEcho "message";
function debugEcho() {
  local _logFile;

  if isDebugEchoEnabled; then
    DEBUG.getDebugLogFile;
    _logFile="${RESULT}";
    echo $* >> "${_logFile}";
  fi
}

# txt: Reverts the module to the default state.
# txt: Returns 0/TRUE always.
# fun: DEBUG.defaultState
# use: DEBUG.defaultState
function DEBUG.defaultState() {
  setDebugLogFile "${TEMP:-/tmp}/$(basename ${SCRIPT_NAME})-debug.$(date '+%Y%m%d%H%M%S').log";
  setDebugEchoEnabled TRUE;
}

# txt: Resets the module.
# txt: Returns 0/TRUE always.
# fun: DEBUG.resetState
# use: DEBUG.resetState
function DEBUG.resetState() {
  setDebugLogFile "";
}

declare -gx __DW_DEBUG_LOG_FILE;
declare -gx __DW_DEBUG_ECHO_ENABLED;

DEBUG.defaultState;
#
