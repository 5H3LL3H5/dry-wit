declare -a __DW_CLI_SHORT_FLAGS;
declare -a __DW_CLI_LONG_FLAGS;
declare -A __DW_CLI_FLAG_EXPECTING_ARGUMENT;
declare -A __DW_CLI_FLAG_CALLBACKS;

# Checks whether a given flag is enabled.
# -> 1: the name of the flag variable.
# <- 0 if the flag is enabled, 1 otherwise.
# Example:
# function parseInput() {
# [..]
#   -my | --myFlag) export MY_FLAG=${TRUE};
#                   ;;
# [..]
# if flagEnabled MY_FLAG; then
#    ..
function flagEnabled() {
  local _flagVar="${1}";
  local _flagVal;
  local -i rescode;

  checkNotEmpty "flagVar" "${_flagVar}" 1;

  _evalVar "${_flagVar}";
  _flagVal="${RESULT}";
  if    areEqual "${_flagVal}" "${TRUE}" \
     || areEqual "${_flagVal}" "TRUE"; then
    rescode=${TRUE};
  else
    rescode=${FALSE};
  fi

  return ${rescode};
}

## Extracts the flags from the arguments.
## -> *: The arguments to process.
## <- [STDOUT]: the flags.
## Example:
##   local _myFlags=$(extractFlags $*);
function extractFlags() {
  echo " $@" \
    | awk -F" -" '{for (i=2; i<=NF; i++){printf("-%s \n", $i);}}' \
    | awk -F" " '{print $1;}'
}

## Extracts the flag value for the arguments.
## -> 1: The flag name.
## -> 2-*: The arguments.
## <- [STDOUT]: the flag value.
## Example:
##   local _Ext=$(extractFlagValue "ext" $*);
function extractFlagValue() {
  local _flag=${1};
  shift;
  echo " $@" \
    | awk -F" -" '{printf("-"); for (i=2; i<=NF; i++){if(i%2 == 1) {printf("-");}; printf("%s \n", $i);}}' \
    | grep -e "^${_flag} " \
    | awk -v f="${_flag}" '{printf("echo \"%s\" | sed -e \"s_^%s __g\"\n", $2, f);}' \
    | sh;
}

## Parses the command-line arguments.
## -> *: The command-line arguments.
## <- 0/${TRUE} if the command-line arguments were parsed successfully; 1/${FALSE} otherwise.
function parseInput() {
  local _flags=$(extractFlags $@);
  local _flagCount;
  local _currentCount;
  local _argument;

  # Flags
  for _flag in ${_flags}; do
    _flagCount=$((_flagCount+1));
    case ${_flag} in
      -h | --help | -v | -vv | -X:e | --X:eval-defaults)
         shift;
         ;;
      -q | --quiet)
        export QUIET=${TRUE};
        shift;
        ;;
      --)
        shift;
        break;
        ;;
    esac
    if arrayContains "${__DW_CLI_SHORT_FLAGS[*]}" "${_flag}" || arrayContains "${__DW_CLI_LONG_FLAGS[*]}" "${_flag}"; then
      if isTrue ${__DW_CLI_EXPECTING_ARGUMENT_FLAGS["${_flag}"]}; then
        _argument="${1}";
        shift;
        ${__DW_CLI_FLAG_CALLBACKS["${_flag}"]} "${_argument}";
      else
        ${__DW_CLI_FLAG_CALLBACKS["${_flag}"]};
      fi
    else
      echo "flag ${_flag} not found in ${__DW_CLI_SHORT_FLAGS} nor ${__DW_CLI_LONG_FLAGS}";
    fi
  done
}

## Adds a command-line flag.
## -> 1: The short name of the flag.
## -> 2: The long name of the flag.
## -> 3: TRUE if the parameter contains a value; FALSE otherwise.
## -> 4: A callback function to parse the value.
## <- 0/${TRUE} if the flag is added successfully; 1/${FALSE} otherwise.
## Example:
##   if addCommandLineFlag "f" "file" TRUE myCallbackFunction; then
##     echo "-f|--file flag added"
##   fi
function addCommandLineFlag() {
  local _shortName="${1}";
  local _longName="${2}";
  local _expectsArgument="${3}";
  local _callback="${4}";
  local -i _rescode=${TRUE};

  checkNotEmpty "shortName" "${_shortName}" 1;
  checkNotEmpty "longName" "${_longName}" 2;
  checkNotEmpty "expectsArgument" "${_expectsArgument}" 3;
  checkNotEmpty "callback" "${_callback}" 4;

  __DW_CLI_SHORT_FLAGS[${#__DW_CLI_SHORT_FLAGS[@]}]="-${_shortName}";
  __DW_CLI_LONG_FLAGS[${#__DW_CLI_LONG_FLAGS[@]}]="--${_longName}";
  __DW_CLI_FLAG_EXPECTING_ARGUMENT["-${_shortName}"]="${_expectsArgument}";
  __DW_CLI_FLAG_EXPECTING_ARGUMENT["--${_longName}"]="${_expectsArgument}";
  __DW_CLI_FLAG_CALLBACKS["-${_shortName}"]="${_callback}";
#  __DW_CLI_FLAG_CALLBACKS["--${_longName}"]="${_callback}";

  return ${_rescode};
}


