declare -a __DW_CLI_FLAG_KEYS;
declare -A __DW_CLI_FLAG_LONG_NAMES;
declare -A __DW_CLI_FLAG_SHORT_NAMES;
declare -A __DW_CLI_MANDATORY_FLAGS;
declare -A __DW_CLI_FLAG_EXPECTING_ARGUMENTS;
declare -A __DW_CLI_FLAG_DESCRIPTIONS;
declare -a __DW_CLI_PARAMETER_NAMES;
declare -A __DW_CLI_PARAMETER_DESCRIPTIONS;
declare -A __DW_CLI_SINGLE_PARAMETERS;
declare -A __DW_CLI_MANDATORY_PARAMETERS;
declare __DW_CLI_SCRIPT_DESCRIPTION;
declare __DW_CLI_SCRIPT_COPYRIGHT;
declare __DW_CLI_SCRIPT_LICENSE_SUMMARY;

export EXPECTS_ARGUMENT=${TRUE};
export NO_ARGUMENT=${FALSE};
export MANDATORY=${TRUE};
export OPTIONAL=${FALSE};
export SINGLE=${FALSE};
export MULTIPLE=${TRUE};

# Checks whether a given flag is enabled.
# -> 1: the name of the flag variable.
# <- 0 if the flag is enabled, 1 otherwise.
# Example:
# function parseInput() {
# [..]
#   -my | --myFlag) export MY_FLAG=${TRUE};
#                   ;;
# [..]
# if flagEnabled MY_FLAG; then
#    ..
function flagEnabled() {
  local _flagVar="${1}";
  local _flagVal;
  local -i rescode;

  checkNotEmpty "flagVar" "${_flagVar}" 1;

  _evalVar "${_flagVar}";
  _flagVal="${RESULT}";
  if    areEqual "${_flagVal}" "${TRUE}" \
     || areEqual "${_flagVal}" "TRUE"; then
    rescode=${TRUE};
  else
    rescode=${FALSE};
  fi

  return ${rescode};
}

## Extracts the flags from the arguments.
## -> *: The arguments to process.
## <- [STDOUT]: the flags.
## Example:
##   local _myFlags=$(extractFlags $*);
function extractFlags() {
  echo " $@" \
    | awk -F" -" '{for (i=2; i<=NF; i++){printf("-%s \n", $i);}}' \
    | awk -F" " '{print $1;}'
}

## Extracts the flag value for the arguments.
## -> 1: The flag name.
## -> 2-*: The arguments.
## <- [STDOUT]: the flag value.
## Example:
##   local _Ext=$(extractFlagValue "ext" $*);
function extractFlagValue() {
  local _flag=${1};
  shift;
  echo " $@" \
    | awk -F" -" '{printf("-"); for (i=2; i<=NF; i++){if(i%2 == 1) {printf("-");}; printf("%s \n", $i);}}' \
    | grep -e "^${_flag} " \
    | awk -v f="${_flag}" '{printf("echo \"%s\" | sed -e \"s_^%s __g\"\n", $2, f);}' \
    | sh;
}

## Retrieves the long format of the flag whose short name is provided.
## -> 1: The long name of the flag.
## <- 0/${TRUE} if the long name is found; 1/${FALSE} otherwise.
## <- RESULT: The long name.
## Example:
##   if CLI.retrieveCommandLineFlagShortNameForLongName "file"; then
##     echo "Short name of 'file' is ${RESULT}";
##   fi
function CLI.retrieveCommandLineFlagShortNameForLongName() {
  local _longName="${1}";
  local -i _rescode;
  local _result;

  checkNotEmpty "longName" "${_longName}" 1;

  _result="${__DW_CLI_FLAG_SHORT_NAMES[${_longName}]}";
  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

## Retrieves whether given flag is in long format.
## -> 1: the flag.
## <- 0/${TRUE} if the flag is in long format; 1/${FALSE} otherwise.
## Example:
##   if CLI.isCommandLineFlagInLongFormat "${flag}"; then
##     echo "Flag ${flag} is in long format";
##   fi
function CLI.isCommandLineFlagInLongFormat() {
  local _flag="${1}";
  local -i _rescode;

  checkNotEmpty "flag" "${_flag}" 1;

  if areEqual "${_flag}" "${_flag#--}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

## Retrieves the short format of the flag whose long name is provided.
## -> 1: The short name of the flag.
## <- 0/${TRUE} if the short name is found; 1/${FALSE} otherwise.
## <- RESULT: The short name.
## Example:
##   if CLI.retrieveCommandLineFlagLongNameForShortName "f"; then
##     echo "Long name of 'f' is ${RESULT}";
##   fi
function CLI.retrieveCommandLineFlagLongNameForShortName() {
  local _shortName="${1}";
  local -i _rescode;
  local _result;

  checkNotEmpty "shortName" "${_shortName}" 1;

  _result="${__DW_CLI_FLAG_LONG_NAMES[${_shortName}]}";
  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

## Retrieves whether given flag is in short format.
## -> 1: the flag.
## <- 0/${TRUE} if the flag is in short format; 1/${FALSE} otherwise.
## Example:
##   if CLI.isCommandLineFlagInShortFormat "${flag}"; then
##     echo "Flag ${flag} is in short format";
##   fi
function CLI.isCommandLineFlagInShortFormat() {
  local _flag="${1}";
  local -i _rescode;

  checkNotEmpty "flag" "${_flag}" 1;

  if areEqual "${_flag}" "${_flag#-}" || CLI.isCommandLineFlagInLongFormat "${_flag}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

## Checks the command-line arguments.
## -> *: The command-line arguments.
## <- 0/${TRUE} if the command-line arguments were checked successfully; 1/${FALSE} otherwise.
function checkInput() {
  local _flags=$(extractFlags $@);
  local _flagCount;
  local _currentCount;
  local _argument;
  local _key;
  local _shortName;
  local _longName;
  local _longNameInUpperCase;
  local _flag;
  local -a _flagsChecked;
  local _oldIFS="${IFS}";
  IFS=$' \t\n';

  # Flags
  for _flag in ${_flags}; do
    IFS="${_oldIFS}";

    _flagCount=$((_flagCount+1));
    case ${_flag} in
      -h | -help | -v | --vv | -X:e | --X:eval-defaults)
         shift;
         ;;
      -q | --quiet)
        export QUIET=${TRUE};
        shift;
        ;;
      --)
        shift;
        break;
        ;;
      *)
        shift;
        ;;
    esac

    if CLI.isCommandLineFlagInLongFormat "${_flag}"; then
      _longName="${_flag#--}";
      if CLI.retrieveCommandLineFlagShortNameForLongName "${_longName}"; then
        _shortName="${RESULT}";
      else
        break;
      fi
    elif CLI.isCommandLineFlagInShortFormat "${_flag}"; then
      _shortName="${_flag#-}";
      if CLI.retrieveCommandLineFlagLongNameForShortName "${_shortName}"; then
        _longName="${RESULT}";
      else
        break;
      fi
    else
      break;
    fi

    CLI.buildCommandLineFlagKey "${_shortName}" "${_longName}";
    _key="${RESULT}";
    _flagsChecked[${#_flagsChecked[@]}]="${_key}";

    if arrayDoesNotContain "${__DW_CLI_FLAG_KEYS[*]}" "${_key}"; then
      echo "Unexpected flag: ${_flag}";
    fi

    if CLI.doesCommandLineFlagExpectArgument "${_key}"; then
      _argument="${1}";
      shift;
      toUpper "${_longName}";
      _longNameInUpperCase="${RESULT}";
      if CLI.isCommandLineFlagMandatory "${_key}" && isEmpty "${_argument}"; then
        exitWithErrorCode "${_longNameInUpperCase}_EXPECTS_AN_ARGUMENT";
      fi
      if isFunctionDefined "dw_check_${_longName}_cli_flag"; then
        "dw_check_${_longName}_cli_flag" "${_argument}";
      fi
    fi
  done

  if isNotEmpty "${__DW_CLI_FLAG_KEYS[*]}"; then
    for _key in ${__DW_CLI_FLAG_KEYS[*]}; do
      IFS="${_oldIFS}";
      CLI.retrieveCommandLineFlagLongNameFromKey "${_key}";
      _longName="${RESULT}";
      toUpper "${_longName}";
      _longNameInUpperCase="${RESULT}";
      if isEmpty "${_flagsChecked[*]}" || arrayDoesNotContain "${_flagsChecked[*]}" "${_key}"; then
        if CLI.isCommandLineFlagMandatory "${_key}"; then
          echo "Exiting - mandatory";
          exitWithErrorCode "${_longNameInUpperCase}_IS_MANDATORY";
        fi
      fi
      if isFunctionDefined "dw_check_${_longName}_cli_flag"; then
        "dw_check_${_longName}_cli_flag";
      fi
    done
    IFS="${_oldIFS}";
  fi
}

## Parses the command-line arguments.
## -> *: The command-line arguments.
## <- 0/${TRUE} if the command-line arguments were parsed successfully; 1/${FALSE} otherwise.
function parseInput() {
  local _flags=$(extractFlags $@);
  local _flagCount;
  local _currentCount;
  local _argument;
  local _key;
  local _shortName;
  local _longName;
  local _oldIFS="${IFS}";
  IFS=$' \t\n';

  # Flags
  for _flag in ${_flags}; do
    IFS="${_oldIFS}";
    _flagCount=$((_flagCount+1));
    case ${_flag} in
      -h | --help | -v | -vv | -X:e | --X:eval-defaults)
         shift;
         ;;
      -q | --quiet)
        export QUIET=${TRUE};
        shift;
        ;;
      --)
        shift;
        break;
        ;;
    esac

    if CLI.isCommandLineFlagInLongFormat "${_flag}"; then
      _longName="${_flag#--}";
      if CLI.retrieveCommandLineFlagShortNameForLongName "${_longName}"; then
        _shortName="${RESULT}";
      else
        break;
      fi
    elif CLI.isCommandLineFlagInShortFormat "${_flag}"; then
      _shortName="${_flag#-}";
      if CLI.retrieveCommandLineFlagLongNameForShortName "${_shortName}"; then
        _longName="${RESULT}";
      else
        break;
      fi
    else
      break;
    fi

    CLI.buildCommandLineFlagKey "${_shortName}" "${_longName}";
    _key="${RESULT}";

    if arrayContains "${__DW_CLI_FLAG_KEYS[*]}" "${_key}"; then
      if isFunctionDefined "dw_parse_${_longName}_cli_flag"; then
        if CLI.doesCommandLineFlagExpectArgument "${_key}"; then
          _argument="${1}";
          shift;
          "dw_parse_${_longName}_cli_flag" "${_argument}";
        else
          "dw_parse_${_longName}_cli_flag";
        fi
      fi
    else
      echo "Unexpected flag: ${_flag}";
    fi
  done
  IFS="${_oldIFS}";
}

## Builds a key for given command-line flag.
## -> 1: The short name of the flag.
## -> 2: The long name of the flag.
## <- 0/${TRUE} if the key was built successfully; 1/${FALSE} otherwise.
## <- RESULT: The key.
## Example:
##   if CLI.buildCommandLineFlagKey "f" "file"; then
##     echo "key: ${RESULT}";
##   fi
function CLI.buildCommandLineFlagKey() {
  local _shortName="${1}";
  local _longName="${2}";
  local -i _rescode=${TRUE};

  checkNotEmpty "shortName" "${_shortName}" 1;
  checkNotEmpty "longName" "${_longName}" 2;

  export RESULT="${_shortName}|${_longName}";

  return ${_rescode};
}

## Retrieves the short name of given command-line flag key.
## -> 1: The key.
## <- 0/${TRUE} if the short name was found; 1/${FALSE} otherwise.
## <- RESULT: The short name.
## Example:
##   if CLI.retrieveCommandLineFlagShortNameFromKey "f|file"; then
##     echo "short name: ${RESULT}";
##   fi
function CLI.retrieveCommandLineFlagShortNameFromKey() {
  local _key="${1}";
  local _result;
  local -i _rescode;

  checkNotEmpty "key" "${_key}" 1;

  _result="${_key%%|*}";
  if areEqual "${_result}" "${_key}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

## Retrieves the long name of given command-line flag key.
## -> 1: The key.
## <- 0/${TRUE} if the long name was found; 1/${FALSE} otherwise.
## <- RESULT: The long name.
## Example:
##   if CLI.retrieveCommandLineFlagLongNameFromKey "f|file"; then
##     echo "long name: ${RESULT}";
##   fi
function CLI.retrieveCommandLineFlagLongNameFromKey() {
  local _key="${1}";
  local _result;
  local -i _rescode;

  checkNotEmpty "key" "${_key}" 1;

  _result="${_key##*|}";
  if areEqual "${_result}" "${_key}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

## Retrieves the description of given command-line flag key.
## -> 1: The key.
## <- 0/${TRUE} if the description was found; 1/${FALSE} otherwise.
## <- RESULT: The description.
## Example:
##   if CLI.retrieveCommandLineFlagDescriptionFromKey "f|file"; then
##     echo "Description: ${RESULT}";
##   fi
function CLI.retrieveCommandLineFlagDescriptionFromKey() {
  local _key="${1}";
  local _result;
  local -i _rescode;

  checkNotEmpty "key" "${_key}" 1;

  _result="${__DW_CLI_FLAG_DESCRIPTIONS[${_key}]}";
  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

## Adds a command-line flag.
## -> 1: The long name of the flag.
## -> 2: The short name of the flag.
## -> 3: The flag description.
## -> 4: EXPECTS_ARGUMENT if the flag contains a value; NO_ARGUMENT otherwise.
## -> 5: MANDATORY if the flag is mandatory; OPTIONAL otherwise.
## <- 0/${TRUE} if the flag is added successfully; 1/${FALSE} otherwise.
## Example:
##   if addCommandLineFlag "file" "f" "The file to read" MANDATORY EXPECTS_ARGUMENT; then
##     echo "-f|--file flag added"
##   fi
function addCommandLineFlag() {
  local _longName="${1}";
  local _shortName="${2}";
  local _description="${3}";
  local _mandatory="${4}";
  local _expectsArgument="${5}";
  local -i _rescode=${TRUE};
  local _flagKey;

  checkNotEmpty "longName" "${_longName}" 1;
  checkNotEmpty "shortName" "${_shortName}" 2;
  checkNotEmpty "description" "${_description}" 3;
  checkOneOf "mandatory" "${_mandatory}" "MANDATORY OPTIONAL" 4;
  checkOneOf "expectsArgument" "${_expectsArgument}" "EXPECTS_ARGUMENT NO_ARGUMENT" 5;

  CLI.buildCommandLineFlagKey "${_shortName}" "${_longName}";
  _flagKey="${RESULT}";

  if    isEmpty "${__DW_CLI_FLAGS[*]}" \
     || arrayDoesNotContain "${__DW_CLI_FLAG_KEYS[*]}" "${_flagKey}"; then
    __DW_CLI_FLAG_KEYS[${#__DW_CLI_FLAGS[@]}]="${_flagKey}";
    __DW_CLI_FLAG_SHORT_NAMES["${_longName}"]="${_shortName}";
    __DW_CLI_FLAG_LONG_NAMES["${_shortName}"]="${_longName}";
    __DW_CLI_FLAG_DESCRIPTIONS["${_flagKey}"]="${_description}";
    toUpper "${_longName}";
    _longNameInUpperCase="${RESULT}";
    if areEqual "${_mandatory}" "MANDATORY"; then
      addError "${_longNameInUpperCase}_IS_MANDATORY" "${_longName} is mandatory";
    fi
    __DW_CLI_MANDATORY_FLAGS["${_flagKey}"]="${_mandatory}";
    if areEqual "${_expectsArgument}" "EXPECTS_ARGUMENT"; then
      addError "${_longNameInUpperCase}_EXPECTS_AN_ARGUMENT" "${_longName} expects an argument";
    fi
    __DW_CLI_FLAG_EXPECTING_ARGUMENTS["${_flagKey}"]="${_expectsArgument}";
  fi

  return ${_rescode};
}

## Checks whether given flag is mandatory or not.
## -> 1: The flag key.
## <- 0/${TRUE} if the flag is mandatory; 1/${FALSE} otherwise.
## Example:
##   if CLI.isCommandLineFlagMandatory ${flagKey}"; then
##     echo "${flagKey} is mandatory";
##   fi
function CLI.isCommandLineFlagMandatory() {
  local _flagKey="${1}";
  local -i _rescode;

  checkNotEmpty "flagKey" "${_flagKey}" 1;

  _value="${__DW_CLI_MANDATORY_FLAGS[${_flagKey}]}";

  if    isEmpty "${_value}" \
    || isTrue "${_value}" \
    || areEqual "${_value}" "MANDATORY"; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

## Checks whether given flag expects an argument.
## -> 1: The flag key.
## <- 0/${TRUE} if the flag expects an argument; 1/${FALSE} otherwise.
## Example:
##   if CLI.doesCommandLineFlagExpectArgument ${flagKey}"; then
##     echo "${flagKey} expects an argument";
##   fi
function CLI.doesCommandLineFlagExpectArgument() {
  local _flagKey="${1}";
  local -i _rescode;

  checkNotEmpty "flagKey" "${_flagKey}" 1;

  _value="${__DW_CLI_FLAG_EXPECTING_ARGUMENTS[${_flagKey}]}";

  if     isEmpty "${_value}" \
      || isTrue "${_value}" \
      || areEqual "${_value}" "EXPECTS_ARGUMENT"; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

## Retrieves the description of given command-line parameter.
## -> 1: The name.
## <- 0/${TRUE} if the description was found; 1/${FALSE} otherwise.
## <- RESULT: The description.
## Example:
##   if CLI.retrieveCommandLineParameterDescriptionFromName "project"; then
##     echo "Description: ${RESULT}";
##   fi
function CLI.retrieveCommandLineParameterDescriptionFromName() {
  local _name="${1}";
  local _result;
  local -i _rescode;

  checkNotEmpty "name" "${_name}" 1;

  _result="${__DW_CLI_PARAMETER_DESCRIPTIONS[${_name}]}";
  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    export RESULT="${_result}";
  fi

  return ${_rescode};
}


## Prints a line describing how to run the script.
## <- 0/${TRUE} if this function printed anything; 1/${FALSE} otherwise.
function CLI.commandLineFlagsUsage() {
  local -i _rescode=${TRUE};
  local _message="${SCRIPT_NAME} [-v[-v]] [-q|--quiet]";
  local _flagKey;
  local _shortName;
  local _longName;
  local _oldIFS="${IFS}";
  local _mandatory;
  IFS=$' \t\n';

  for _flagKey in ${__DW_CLI_FLAG_KEYS[@]}; do
    IFS="${_oldIFS}";
    CLI.retrieveCommandLineFlagShortNameFromKey "${_flagKey}";
    _shortName="${RESULT}";
    CLI.retrieveCommandLineFlagLongNameFromKey "${_flagKey}";
    _longName="${RESULT}";
    _message="${_message} ";
    CLI.isCommandLineFlagMandatory "${_flagKey}";
    _mandatory=$?;
    if isFalse ${_mandatory}; then
      _message="${_message}[";
    fi
    _message="${_message}-${_shortName}|--${_longName}";
    if CLI.doesCommandLineFlagExpectArgument "${_flagKey}"; then
      _message="${_message} arg";
    fi
    if isFalse ${_mandatory}; then
      _message="${_message}]";
    fi
  done
  IFS="${_oldIFS}";

  echo -n "${_message}";

  return ${_rescode};
}

## Conditionally prints (to stdout) a line with the script description.
## <- 0/${TRUE} if this function printed anything; 1/${FALSE} otherwise.
function CLI.scriptDescriptionUsage() {
  local -i _rescode;
  if isEmpty "${__DW_CLI_SCRIPT_DESCRIPTION}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    echo -e "\n${__DW_CLI_SCRIPT_DESCRIPTION}\n";
  fi

  return ${_rescode};
}

## Conditionally prints (to stdout) a line with the license summary.
## <- 0/${TRUE} if this function printed anything; 1/${FALSE} otherwise.
function CLI.scriptLicenseSummaryUsage() {
  local -i _rescode;
  if isEmpty "${__DW_CLI_SCRIPT_LICENSE_SUMMARY}"; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
    echo "${__DW_CLI_SCRIPT_LICENSE_SUMMARY}";
  fi

  return ${_rescode};
}

## Conditionally prints (to stdout) a line with the copyright.
## <- 0/${TRUE} if this function printed anything; 1/${FALSE} otherwise.
function CLI.scriptCopyrightUsage() {
  local -i _rescode;

  if isEmpty "${__DW_CLI_SCRIPT_COPYRIGHT}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    echo "${__DW_CLI_SCRIPT_COPYRIGHT}";
  fi

  return ${_rescode};
}

## Prints a line describing the details of the command-line flags.
## <- 0/${TRUE} if this function printed anything; 1/${FALSE} otherwise.
function CLI.commandLineFlagsDetailedUsage() {
  local -i _rescode;
  local _message;
  local _flagKey;
  local _shortName;
  local _longName;
  local _description;
  local _oldIFS="${IFS}";
  IFS=$' \t\n';

  for _flagKey in ${__DW_CLI_FLAG_KEYS[@]}; do
    IFS="${_oldIFS}";
    CLI.retrieveCommandLineFlagShortNameFromKey "${_flagKey}";
    _shortName="${RESULT}";
    CLI.retrieveCommandLineFlagLongNameFromKey "${_flagKey}";
    _longName="${RESULT}";
    CLI.retrieveCommandLineFlagDescriptionFromKey "${_flagKey}";
    _description="${RESULT}";
    _message="${_message}  * -${_shortName}|--${_longName}";
    if CLI.doesCommandLineFlagExpectArgument "${_flagKey}"; then
      _message="${_message} arg";
    fi
    _message="${_message}: ${_description}.";
    if CLI.isCommandLineFlagMandatory "${_flagKey}"; then
      _message="${_message} Mandatory.\n";
    else
      _message="${_message} Optional.\n";
    fi
  done
  IFS="${_oldIFS}";

  if isEmpty "${_message}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    echo -n -e "${_message}";
  fi

  return ${_rescode};
}

## Declares the script expects another command-line parameter.
## -> 1: The parameter name.
## -> 2: The parameter description.
## -> 3: MANDATORY if the parameter is mandatory; OPTIONAL otherwise.
## -> 4: SINGLE if the parameter can not be repeated; MULTIPLE otherwise.
## <- 0/${TRUE} if the parameter was added successfully; 1/${FALSE} otherwise.
## Example:
##   addCommandLineParameter "project" "The project to process" MANDATORY SINGLE;
function addCommandLineParameter() {
  local _name="${1}";
  local _description="${2}";
  local _mandatoryOrOptional="${3}";
  local _singleOrMultiple="${4}";

  checkNotEmpty "name" "${_name}" 1;
  checkNotEmpty "description" "${_description}" 2;
  checkOneOf "mandatory/optional" "${_mandatoryOrOptional}" "MANDATORY OPTIONAL" 3;
  checkOneOf "single/multiple" "${_singleOrMultiple}" "SINGLE MULTIPLE" 4;

  if    isEmpty "${__DW_CLI_PARAMETER_NAMES[*]}" \
     || arrayDoesNotContain "${__DW_CLI_PARAMETER_NAMES[*]}" "${_name}"; then
    __DW_CLI_PARAMETER_NAMES[${#__DW_CLI_PARAMETER_NAMES[@]}]="${_name}";
    __DW_CLI_PARAMETER_DESCRIPTIONS["${_name}"]="${_description}";
    __DW_CLI_MANDATORY_PARAMETERS["${_name}"]="${_mandatoryOrOptional}";
    __DW_CLI_SINGLE_PARAMETERS["${_name}"]="${_singleOrMultiple}";
  fi

  return ${TRUE};
}

## Checks whether given parameter is single or not.
## -> 1: The parameter name.
## <- 0/${TRUE} if the parameter is single; 1/${FALSE} otherwise.
## Example:
##   if CLI.commandLineParameterIsSingle ${name}"; then
##     echo "${name} is multiple";
##   fi
function CLI.commandLineParameterIsSingle() {
  local _name="${1}";
  local -i _rescode;

  checkNotEmpty "name" "${_name}" 1;

  _value="${__DW_CLI_SINGLE_PARAMETERS[${_name}]}";

  if    isEmpty "${_value}" \
     || isTrue "${_value}" \
     || areEqual "${_value}" "SINGLE"; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

## Checks whether given parameter is multiple or not.
## -> 1: The parameter name.
## <- 0/${TRUE} if the parameter is multiple; 1/${FALSE} otherwise.
## Example:
##   if CLI.commandLineParameterIsMultiple ${name}"; then
##     echo "${name} is multiple";
##   fi
function CLI.commandLineParameterIsMultiple() {
  local _name="${1}";
  local -i _rescode;

  checkNotEmpty "name" "${_name}" 1;

  if CLI.commandLineParameterIsSingle "${_name}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

## Checks whether given parameter is mandatory or not.
## -> 1: The parameter name.
## <- 0/${TRUE} if the parameter is mandatory; 1/${FALSE} otherwise.
## Example:
##   if CLI.commandLineParameterIsMandatory ${name}"; then
##     echo "${name} is mandatory";
##   fi
function CLI.commandLineParameterIsMandatory() {
  local _name="${1}";
  local -i _rescode;

  checkNotEmpty "name" "${_name}" 1;

  _value="${__DW_CLI_MANDATORY_PARAMETERS[${_name}]}";

  if    isEmpty "${_value}" \
      || isTrue "${_value}" \
      || areEqual "${_value}" "MANDATORY"; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

## Prints a line describing the script's flags.
## <- 0/${TRUE} if this function printed anything; 1/${FALSE} otherwise.
function CLI.commandLineParametersUsage() {
  local -i _rescode;
  local _message;
  local _name;
  local _oldIFS="${IFS}";
  local _mandatory;
  IFS=$' \t\n';

  for _name in ${__DW_CLI_PARAMETER_NAMES[@]}; do
    IFS="${_oldIFS}";
    _message="${_message} ${_name}";
    if CLI.commandLineParameterIsMultiple "${_name}"; then
      if CLI.isCommandLineFlagMandatory "${_name}"; then
        _message="${_message}+";
      else
        _message="${_message}*";
      fi
    fi
  done
  IFS="${_oldIFS}";

  if isEmpty "${_message}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    echo -e "${_message}";
  fi

  return ${_rescode};
}

## Prints a line describing the details of the command-line parameters.
## <- 0/${TRUE} if this function printed anything; 1/${FALSE} otherwise.
function CLI.commandLineParametersDetailedUsage() {
  local -i _rescode;
  local _message;
  local _name;
  local _description;
  local _oldIFS="${IFS}";
  IFS=$' \t\n';

  for _name in ${__DW_CLI_PARAMETER_NAMES[@]}; do
    IFS="${_oldIFS}";
    if isNotEmpty "${_message}"; then
      _message="\n";
    fi
    CLI.retrieveCommandLineParameterDescriptionFromName "${_name}";
    _description="${RESULT}";
    _message="${_message}  * ${_name}";
    if CLI.commandLineParameterIsMultiple "${_name}"; then
      _message="${_message}*";
    fi
    _message="${_message}: ${_description}.";
    if CLI.commandLineParameterIsMandatory "${_name}"; then
      _message="${_message} Mandatory.";
    else
      _message="${_message} Optional.";
    fi
  done
  IFS="${_oldIFS}";

  if isEmpty "${_message}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    echo -e "${_message}";
  fi

  return ${_rescode};
}


## Sets the script copyright message.
## -> 1: The copyright message.
## <- 0/${TRUE} always.
## Example:
##   setScriptCopyrightMessage "2018-today Acme Inc.";
function setScriptCopyright() {
  local _copyright="${1}";

  checkNotEmpty "copyright" "${_copyright}" 1;

  __DW_CLI_SCRIPT_COPYRIGHT="${_copyright}";

  return ${TRUE};
}

## Sets the script license summary.
## -> 1: The license message.
## <- 0/${TRUE} always.
## Example:
##   setScriptLicenseSummary "Distributed this under the GNU General Public License v3.";
function setScriptLicenseSummary() {
  local _license="${1}";

  checkNotEmpty "license" "${_license}" 1;

  __DW_CLI_SCRIPT_LICENSE_SUMMARY="${_license}";

  return ${TRUE};
}

## Defines the script description.
## -> 1: The description.
## <- 0/${TRUE} in any case.
## Example:
##   setScriptDescription "This script calculates fibonacci sequence items"
function setScriptDescription() {
  local _description="${1}";

  checkNotEmpty "description" "${_description}" 1;

  __DW_CLI_SCRIPT_DESCRIPTION="${_description}";
}

## Prints the usage description.
function usage() {
  CLI.commandLineFlagsUsage
  if ! CLI.commandLineParametersUsage; then
    echo;
  fi
  echo "${SCRIPT_NAME} [-h|--help]";
  CLI.scriptCopyrightUsage
  CLI.scriptLicenseSummaryUsage;
  if ! CLI.scriptDescriptionUsage; then
    echo;
  fi
  echo "Where:"
  CLI.commandLineFlagsDetailedUsage
  CLI.commandLineParametersDetailedUsage
  echo "  * -h | --help: Display this message.";
  echo "  * -v: Increase the verbosity.";
  echo "  * -vv: Increase the verbosity further.";
  echo "  * -q | --quiet: Be silent.";
}

## Resets all internal state.
function CLI.resetState() {
  __DW_CLI_FLAG_KEYS=();
  __DW_CLI_FLAG_LONG_NAMES=();
  __DW_CLI_FLAG_SHORT_NAMES=();
  __DW_CLI_MANDATORY_FLAGS=();
  __DW_CLI_FLAG_EXPECTING_ARGUMENTS=();
  __DW_CLI_FLAG_DESCRIPTIONS=();
  __DW_CLI_PARAMETER_NAMES=();
  __DW_CLI_PARAMETER_DESCRIPTIONS=();
  __DW_CLI_MANDATORY_PARAMETERS=();
  __DW_CLI_SINGLE_PARAMETERS=();
  __DW_CLI_SCRIPT_DESCRIPTION="";
  __DW_CLI_SCRIPT_COPYRIGHT="";
  __DW_CLI_SCRIPT_LICENSE_SUMMARY="";
}
#
