# mod: cli
declare -gx EXPECTS_ARGUMENT=${TRUE};
declare -gx NO_ARGUMENT=${FALSE};
declare -gx SINGLE=${FALSE};
declare -gx MULTIPLE=${TRUE};


# txt: Sets the script copyright message.
# txt: Returns 0/TRUE always.
# fun: setScriptCopyright copyrightDescription
# opt: copyrightDescription: The copyright message.
# api: setScriptCopyright
# use: setScriptCopyright "2018-today Acme Inc.";
function setScriptCopyright() {
  local _copyright="${1}";

  checkNotEmpty "copyright" "${_copyright}" 1;

  __DW_CLI_SCRIPT_COPYRIGHT="${_copyright}";

  return ${TRUE};
}

# txt: Sets the script license summary.
# txt: Returns 0/TRUE always.
# fun: setScriptLicenseSummary licenseDescription
# opt: licenseDescription: The license message.
# api: setScriptLicenseSummary
# use: setScriptLicenseSummary "Distributed this under the GNU General Public License v3.";
function setScriptLicenseSummary() {
  local _license="${1}";

  checkNotEmpty "license" "${_license}" 1;

  __DW_CLI_SCRIPT_LICENSE_SUMMARY="${_license}";

  return ${TRUE};
}

# txt: Defines the script description.
# txt: Returns 0/TRUE in any case.
# fun: setScriptDescription description
# opt: description: The description.
# use: setScriptDescription "This script calculates fibonacci sequence items"
function setScriptDescription() {
  local _description="${1}";

  checkNotEmpty "description" "${_description}" 1;

  __DW_CLI_SCRIPT_DESCRIPTION="${_description}";
}

# txt: Declares the script expects another command-line parameter.
# txt: Returns 0/TRUE if the parameter was added successfully; 1/FALSE otherwise.
# fun: addCommandLineParameter paramName paramDescription MANDATORY/OPTIONAL SINGLE/MULTIPLE
# opt: paramName: The parameter name.
# opt: paramDescription: The parameter description.
# opt: MANDATORY/OPTIONAL: MANDATORY if the parameter is mandatory; OPTIONAL otherwise.
# opt: SINGLE/MULTIPLE: SINGLE if the parameter can not be repeated; MULTIPLE otherwise.
# api: addCommandLineParameter
# use: addCommandLineParameter "project" "The project to process" MANDATORY SINGLE;
function addCommandLineParameter() {
  local _name="${1}";
  local _description="${2}";
  local _mandatoryOrOptional="${3}";
  local _singleOrMultiple="${4}";

  checkNotEmpty "name" "${_name}" 1;
  checkNotEmpty "description" "${_description}" 2;
  checkOneOf "mandatory/optional" "${_mandatoryOrOptional}" "MANDATORY OPTIONAL" 3;
  checkOneOf "single/multiple" "${_singleOrMultiple}" "SINGLE MULTIPLE" 4;

  if    isEmpty "${__DW_CLI_PARAMETER_NAMES[*]}" \
     || arrayDoesNotContain "${__DW_CLI_PARAMETER_NAMES[*]}" "${_name}"; then
    __DW_CLI_PARAMETER_NAMES[${#__DW_CLI_PARAMETER_NAMES[@]}]="${_name}";
    __DW_CLI_PARAMETER_DESCRIPTIONS["${_name}"]="${_description}";
    __DW_CLI_MANDATORY_PARAMETERS["${_name}"]="${_mandatoryOrOptional}";
    __DW_CLI_SINGLE_PARAMETERS["${_name}"]="${_singleOrMultiple}";
  fi

  return ${TRUE};
}

# txt: Adds a command-line flag.
# txt: Returns 0/TRUE if the flag is added successfully; 1/FALSE otherwise.
# fun: addCommandLineFlag longName shortName description MANDATORY/OPTIONAL EXPECTS_ARGUMENT/NO_ARGUMENT defaultValue?
# opt: longName: The long name of the flag.
# opt: shortName: The short name of the flag.
# opt: description: The flag description.
# opt: MANDATORY/OPTIONAL: MANDATORY if the flag is mandatory; OPTIONAL otherwise.
# opt: EXPECTS_ARGUMENT/NO_ARGUMENT: EXPECTS_ARGUMENT if the flag contains a value; NO_ARGUMENT otherwise.
# opt: defaultValue: The default value (if the flag is optional).
# api: addCommandLineFlag
# use: if addCommandLineFlag "file" "f" "The file to read" MANDATORY EXPECTS_ARGUMENT "/tmp/file.log"; then
# use:   echo "-f|--file flag added"
# use: fi
function addCommandLineFlag() {
  local _longName="${1}";
  local _shortName="${2}";
  local _description="${3}";
  local _mandatory="${4}";
  local _expectsArgument="${5}";
  local _defaultValue="${6}";
  local -i _rescode=${TRUE};
  local _flagKey;
  local _longNameInUpperCase;

  checkNotEmpty "longName" "${_longName}" 1;
  checkNotEmpty "shortName" "${_shortName}" 2;
  checkNotEmpty "description" "${_description}" 3;
  checkOneOf "mandatory" "${_mandatory}" "MANDATORY OPTIONAL" 4;
  checkOneOf "expectsArgument" "${_expectsArgument}" "EXPECTS_ARGUMENT NO_ARGUMENT" 5;

  if removePrefix "${_longName}" "-*"; then
    _longName="${RESULT}";
  fi
  if removePrefix "${_shortName}" "-*"; then
    _shortName="${RESULT}";
  fi

  CLI.buildCommandLineFlagKey "${_shortName}" "${_longName}";
  _flagKey="${RESULT}";

  if   isEmpty "${__DW_CLI_FLAG_KEYS[*]}" \
    || arrayDoesNotContain "${__DW_CLI_FLAG_KEYS[*]}" "${_flagKey}"; then
    __DW_CLI_FLAG_KEYS[${#__DW_CLI_FLAG_KEYS[@]}]="${_flagKey}";
    __DW_CLI_FLAG_SHORT_NAMES[${_longName}]="${_shortName}";
    __DW_CLI_FLAG_LONG_NAMES[${_shortName}]="${_longName}";
    __DW_CLI_FLAG_DESCRIPTIONS[${_flagKey}]="${_description}";
    normalizeUppercase "${_longName}";
    _longNameInUpperCase="${RESULT}";
    if areEqual "${_mandatory}" "MANDATORY"; then
      addError "${_longNameInUpperCase}_IS_MANDATORY" "${_longName} is mandatory";
    fi
    __DW_CLI_MANDATORY_FLAGS[${_flagKey}]=${_mandatory};
    if areEqual "${_expectsArgument}" "EXPECTS_ARGUMENT"; then
      addError "${_longNameInUpperCase}_EXPECTS_AN_ARGUMENT" "${_longName} expects an argument";
    fi
    __DW_CLI_FLAG_EXPECTING_ARGUMENTS[${_flagKey}]="${_expectsArgument}";
    __DW_CLI_OPTIONAL_FLAG_DEFAULT_VALUES[${_flagKey}]="${_defaultValue}";
  fi

  return ${_rescode};
}

# txt: Removes a command-line flag.
# txt: Returns 0/TRUE if the flag is removed successfully; 1/FALSE otherwise.
# fun: removeCommandLineFlag shortOrLongName
# opt: shortOrLongName: The flag (either short or long name).
# api: removeCommandLineFlag
# use: if removeCommandLineFlag "--file"; then
# use:   echo "--file flag removed";
# use: fi
function removeCommandLineFlag() {
  local _flag="${1}";
  local _longName;
  local _shortName;
  local -i _rescode;
  local _flagKey;

  checkNotEmpty "flag" "${_flag}" 1;

  if CLI.retrieveCommandLineFlagKey "${_flag}"; then
    _flagKey="${RESULT}";

    if   isNotEmpty "${_flagKey}" \
      && isNotEmpty "${__DW_CLI_FLAG_KEYS[*]}" \
      && arrayContains "${__DW_CLI_FLAG_KEYS[*]}" "${_flagKey}"; then
      __DW_CLI_FLAG_KEYS=( "${__DW_CLI_FLAG_KEYS[@]/${_flagKey}}" );
      CLI.retrieveCommandLineFlagLongNameFromKey "${_flagKey}";
      _longName="${RESULT}";
      CLI.retrieveCommandLineFlagShortNameFromKey "${_flagKey}";
      _shortName="${RESULT}";
      unset __DW_CLI_FLAG_SHORT_NAMES[${_longName}];
      unset __DW_CLI_FLAG_LONG_NAMES[${_shortName}];
      unset __DW_CLI_FLAG_DESCRIPTIONS[${_flagKey}];
      unset __DW_CLI_MANDATORY_FLAGS[${_flagKey}];
      unset __DW_CLI_FLAG_EXPECTING_ARGUMENTS[${_flagKey}];
      unset __DW_CLI_OPTIONAL_FLAG_DEFAULT_VALUES[${_flagKey}];
    fi

  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# txt: Prints the usage description.
# txt: Returns 0/TRUE always.
# fun: usage
# api: usage
# use: usage
function usage() {
  CLI.commandLineFlagsUsage
  if ! CLI.commandLineParametersUsage; then
    echo;
  fi
  CLI.scriptCopyrightUsage
  CLI.scriptLicenseSummaryUsage;
  if ! CLI.scriptDescriptionUsage; then
    echo;
  fi
  echo "Where:"
  CLI.commandLineFlagsDetailedUsage
  CLI.commandLineParametersDetailedUsage
}

# txt: Checks the command-line arguments.
# txt: Returns 0/TRUE if the command-line arguments were checked successfully; 1/FALSE otherwise.
# fun: checkInput arguments
# opt: arguments: The command-line arguments.
# api: checkInput
# use: if checkInput *@; then ... fi
function checkInput() {
    local _flags=$(CLI.extractFlags $@);
    local _flag;
    local -a _flagsChecked=();
    local _oldIFS="${IFS}";

    # Flags
    IFS="${DWIFS}";
    for _flag in ${_flags}; do
        IFS="${_oldIFS}";
        _flagCount=$((_flagCount+1));
        shift;

        CLI.checkFlag "${_flag}" $@;
        _flagsChecked[${#_flagsChecked[@]}]="${_flag}";
    done
    IFS="${_oldIFS}";

    CLI.checkForMissingMandatoryCommandLineFlags "${_flagsChecked[*]}";

    CLI.checkCommandLineParameters $@;

    CLI.checkEnvironmentVariables;
}

# txt: Parses the command-line arguments.
# txt: Returns 0/TRUE if the command-line arguments were parsed successfully; 1/FALSE otherwise.
# fun: parseInput arguments
# opt: arguments: The command-line arguments.
# use: parseInput *@
function parseInput() {
    local _flags=$(CLI.extractFlags $@);
    local _oldIFS="${IFS}";
    local -i _i;
    local -a _providedFlags=();
    local _flag;

    # Flags
    IFS="${DWIFS}";
    for _flag in ${_flags}; do
        IFS="${_oldIFS}";
        shift;
        _providedFlags[${#_providedFlags[@]}]="${_flag}";

        CLI.parseFlag "${_flag}" ${@};
        _shifts=$?;
        IFS="${DWIFS}";
        for _i in $(seq 1 ${_shifts}); do
            IFS="${_oldIFS}";
            shift;
        done
    done
    IFS="${_oldIFS}";

    CLI.parseNotProvidedFlags "${_providedFlags[*]}";

    CLI.parseCommandLineParameters ${@};
}

# txt: Checks whether a given flag is enabled.
# txt: Returns 0/TRUE if the flag is enabled, 1/FALSE otherwise.
# fun: flagEnabled flagName
# opt: flagName: the name of the flag variable.
# api: flagEnabled
# use: if flagEnabled MY_FLAG; then ...
function flagEnabled() {
  local _flagVar="${1}";
  local _flagVal;
  local -i rescode;

  checkNotEmpty "flagVar" "${_flagVar}" 1;

  evalVar "${_flagVar}";
  _flagVal="${RESULT}";
  if    areEqual "${_flagVal}" "${TRUE}" \
     || areEqual "${_flagVal}" "TRUE"; then
    rescode=${TRUE};
  else
    rescode=${FALSE};
  fi

  return ${rescode};
}

# txt: Callback function when the user includes the debug (-v|--debug) flag.
# txt: It's based on a naming convention: dw_parse_[flag]_cli_flag
# fun: dw_parse_debug_cli_flag
function dw_parse_debug_cli_flag() {
    setDebugEnabled;
}

# txt: Callback function when the user includes the trace (-vv|--trace) flag.
# txt: It's based on a naming convention: dw_parse_[flag]_cli_flag
# fun: dw_parse_trace_cli_flag
function dw_parse_trace_cli_flag() {
    setTraceEnabled;
}

# txt: Callback function when the user includes the quiet (-q|--quiet) flag.
# txt: It's based on a naming convention: dw_parse_[flag]_cli_flag
# fun: dw_parse_quiet_cli_flag
function dw_parse_quiet_cli_flag() {
    export QUIET=${TRUE};
}

# txt: Callback function when the user includes the help (-h|--help) flag.
# txt: It's based on a naming convention: dw_check_[flag]_cli_flag
# fun: dw_parse_help_cli_flag
function dw_parse_help_cli_flag() {
    printHelp;
}

# txt: Extracts the flags from the arguments.
# txt: Prints the flags to stdout.
# fun: CLI.extractFlags cliArguments
# opt: cliArguments: The arguments to process.
# use: local _myFlags=$(CLI.extractFlags $*);
function CLI.extractFlags() {
  echo " $@" \
    | awk -F" -" '{for (i=2; i<=NF; i++){printf("-%s \n", $i);}}' \
    | awk -F" " '{print $1;}'
}

# txt: Extracts the flag value for the arguments.
# txt: Prints the flag value to stdout.
# fun: CLI.extractFlagValue flagName cliArguments
# opt: flagName: the name of the flag.
# opt: cliArguments: The arguments to process.
# use: local _Ext=$(CLI.extractFlagValue "ext" $*);
function CLI.extractFlagValue() {
  local _flag=${1};
  shift;
  echo " $@" \
    | awk -F" -" '{printf("-"); for (i=2; i<=NF; i++){if(i%2 == 1) {printf("-");}; printf("%s \n", $i);}}' \
    | grep -e "^${_flag} " \
    | awk -v f="${_flag}" '{printf("echo \"%s\" | sed -e \"s_^%s __g\"\n", $2, f);}' \
    | sh;
}

# txt: Retrieves the short format of the flag whose long name is provided.
# txt: Returns 0/TRUE if the long name is found; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT will contain the short name of the flag.
# fun: CLI.retrieveCommandLineFlagShortNameForLongName longName
# opt: longName: The long name of the flag.
# use: if CLI.retrieveCommandLineFlagShortNameForLongName "file"; then
# use    echo "Short name of 'file' is ${RESULT}";
# use  fi
function CLI.retrieveCommandLineFlagShortNameForLongName() {
  local _longName="${1}";
  local -i _rescode;
  local _result;

  checkNotEmpty "longName" "${_longName}" 1;

  _result="${__DW_CLI_FLAG_SHORT_NAMES[${_longName}]}";
  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# txt: Retrieves whether given flag is in long format.
# txt: Returns 0/TRUE if the flag is in long format; 1/FALSE otherwise.
# fun: CLI.isCommandLineFlagInLongFormat flag
# opt: flag: the flag.
# use: if CLI.isCommandLineFlagInLongFormat "${flag}"; then
# use:   echo "Flag ${flag} is in long format";
# use:  fi
function CLI.isCommandLineFlagInLongFormat() {
  local _flag="${1}";
  local -i _rescode;

  checkNotEmpty "flag" "${_flag}" 1;

  if areEqual "${_flag}" "${_flag#--}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

# txt: Retrieves the short format of the flag whose long name is provided.
# txt: Returns 0/TRUE if the short name is found; 1/FALSE otherwise.
# fun: CLI.retrieveCommandLineFlagLongNameForShortName shortName
# opt: shortName: The short name of the flag.
# use: if CLI.retrieveCommandLineFlagLongNameForShortName "f"; then
# use:   echo "Long name of 'f' is ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagLongNameForShortName() {
  local _shortName="${1}";
  local -i _rescode;
  local _result;

  checkNotEmpty "shortName" "${_shortName}" 1;

  _result="${__DW_CLI_FLAG_LONG_NAMES[${_shortName}]}";
  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# txt: Retrieves whether given flag is in short format.
# txt: Returns 0/TRUE if the flag is in short format; 1/FALSE otherwise.
# fun: CLI.isCommandLineFlagInShortFormat flag
# opt: flag: The flag.
# use: if CLI.isCommandLineFlagInShortFormat "${flag}"; then
# use:   echo "Flag ${flag} is in short format";
# use: fi
function CLI.isCommandLineFlagInShortFormat() {
  local _flag="${1}";
  local -i _rescode;

  checkNotEmpty "flag" "${_flag}" 1;

  if areEqual "${_flag}" "${_flag#-}" || CLI.isCommandLineFlagInLongFormat "${_flag}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

# txt: Performs some checks on given flag.
# txt: It exits the script if the flag is unknown.
# fun: CLI.checkFlag flag
# opt: flag: The flag to check.
# use: CLI.checkFlag "-f";
function CLI.checkFlag() {
  local _flag="${1}";
  shift;
  local _flagKey;
  local _shortName;
  local _longName;
  local _continue=${TRUE};

  checkNotEmpty "flag" "${_flag}" 1;

  case ${_flag} in
    --)
      shift;
      _continue=${FALSE};
      ;;
  esac

  if isTrue ${_continue}; then
    if CLI.retrieveCommandLineFlagLongName "${_flag}"; then
      _longName="${RESULT}";
    else
      exitWithError UNKNOWN_FLAG "Unknown flag ${_flag}";
    fi

    if CLI.retrieveCommandLineFlagShortName "${_flag}"; then
      _shortName="${RESULT}";
    else
      exitWithError UNKNOWN_FLAG "Unknown flag ${_flag}";
    fi

    CLI.buildCommandLineFlagKey "${_shortName}" "${_longName}";
    _flagKey="${RESULT}";

    if arrayDoesNotContain "${__DW_CLI_FLAG_KEYS[*]}" "${_flagKey}"; then
      exitWithError UNKNOWN_FLAG "Unknown flag ${_flag}";
    fi

    CLI.checkCommandLineFlag "${_flagKey}" "${_longName}" $@;
  fi
}

# txt: Retrieves the long name of a flag.
# txt: Returns 0/TRUE if the long name was retrieved; 1/FALSE otherwise.
# txt: If the script returns 0/TRUE, the variable RESULT will contain the long name of the flag.
# fun: CLI.retrieveCommandLineFlagLongName flag
# opt: flag: The flag.
# use: if CLI.retrieveCommandLineFlagLongName "-f"; then
# use:   echo "long name: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagLongName() {
  local _flag="${1}";
  local _result;
  local -i _rescode;

  checkNotEmpty "flag" "${_flag}" 1;

  if CLI.isCommandLineFlagInLongFormat "${_flag}"; then
    _result="${_flag#--}";
    _rescode=${TRUE};
  elif CLI.isCommandLineFlagInShortFormat "${_flag}" && CLI.retrieveCommandLineFlagLongNameForShortName "${_flag#-}"; then
    _result="${RESULT}";
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# txt: Retrieves the short name of a flag.
# txt: Returns 0/TRUE if the short name was retrieved; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, then the variable RESULT contains the short name of the flag.
# fun: CLI.retrieveCommandLineShortName flag
# opt: flag: The flag.
# use: if CLI.retrieveCommandLineShortName "--file"; then
# use:   echo "short name: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagShortName() {
  local _flag="${1}";
  local _result;
  local -i _rescode;

  checkNotEmpty "flag" "${_flag}" 1;

  if CLI.isCommandLineFlagInLongFormat "${_flag}" && CLI.retrieveCommandLineFlagShortNameForLongName "${_flag#--}"; then
    _result="${RESULT}";
    _rescode=${TRUE};
  elif CLI.isCommandLineFlagInShortFormat "${_flag}"; then
    _result="${_flag#-}";
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# txt: Checks a command line flag.
# fun: CLI.checkCommandLineFlag flagKey
# opt: flagKey: The key of the flag.
# use: CLI.checkCommandLineFlag "${_flagKey}";
function CLI.checkCommandLineFlag() {
  local _flagKey="${1}";
  local _longName="${2}";
  shift;
  shift;
  local _argument;
  local _longNameInUpperCase;
  local -i _functionDefined;
  local -i _mandatory;

  checkNotEmpty "flagKey" "${_flagKey}" 1;
  checkNotEmpty "longName" "${_longName}" 2;

  if isFunctionDefined "dw_check_${_longName}_cli_flag"; then
    _functionDefined=${TRUE};
  fi

  if CLI.isCommandLineFlagMandatory "${_flagKey}"; then
    _mandatory=${TRUE};
  fi

  if CLI.doesCommandLineFlagExpectArgument "${_flagKey}"; then
    _argument="${1}";
    shift;
    toUpper "${_longName}";
    _longNameInUpperCase="${RESULT}";
    if isTrue ${_mandatory} && isEmpty "${_argument}"; then
      exitWithError "${_longNameInUpperCase}_EXPECTS_AN_ARGUMENT" "${_longName} flag expects an argument";
    fi
    if isTrue ${_functionDefined}; then
      "dw_check_${_longName}_cli_flag" "${_argument}";
    fi
  elif isTrue ${_functionDefined}; then
    "dw_check_${_longName}_cli_flag";
  fi
}

# txt: Checks for mandatory command line flags that are declared but not provided.
# fun: CLI.checkForMissingMandatoryCommandLineFlags flags
# opt: flags: The flags provided.
# use: CLI.checkForMissingMandatoryCommandLineFlags "-f --file -v -vv";
function CLI.checkForMissingMandatoryCommandLineFlags() {
  local _flagsChecked="$@";
  local _key;
  local _longName;
  local _longNameInUpperCase;
  local _oldIFS="${IFS}";

  if isNotEmpty "${__DW_CLI_FLAG_KEYS[*]}"; then
    IFS="${DWIFS}";
    for _key in ${__DW_CLI_FLAG_KEYS[*]}; do
      IFS="${_oldIFS}";
      CLI.retrieveCommandLineFlagLongNameFromKey "${_key}";
      _longName="${RESULT}";
      toUpper "${_longName}";
      _longNameInUpperCase="${RESULT}";
      if isEmpty "${_flagsChecked}" || ! CLI.isCommandLineFlagAlreadyChecked "${_flagsChecked}" "${_key}"; then
        if CLI.isCommandLineFlagMandatory "${_key}"; then
          exitWithError "${_longNameInUpperCase}_IS_MANDATORY" "${_longName} flag is mandatory";
        fi
      fi
      if isFunctionDefined "dw_check_${_longName}_cli_flag"; then
        "dw_check_${_longName}_cli_flag";
      fi
    done
    IFS="${_oldIFS}";
  fi
}

# txt: Checks whether the flag has been already checked.
# txt: Returns 0/TRUE if the flag has been checked; 1/FALSE otherwise.
# fun: CLI.isCommandLineFlagAlreadyChecked alreadyCheckedFlags flagKey
# opt: alreadyCheckedFlags: The already-checked flags.
# opt: flagKey: The flag key to check.
# use: if CLI.isCommandLineFlagAlreadyChecked "-f -v -h" "${flagKey}"; then
# use:   echo "${flagKey} already checked";
# use: fi
function CLI.isCommandLineFlagAlreadyChecked() {
  local _flagsAlreadyChecked="${1}";
  local _flagKey="${2}";
  local -i _rescode;

  checkNotEmpty "flagsAlreadyChecked" "${_flagsAlreadyChecked}" 1;
  checkNotEmpty "flagKey" "${_flagKey}" 2;

  CLI.retrieveCommandLineFlagLongNameFromKey "${_flagKey}";
  _longName="--${RESULT}";
  CLI.retrieveCommandLineFlagShortNameFromKey "${_flagKey}";
  _shortName="-${RESULT}";

  if    arrayContains "${_flagsAlreadyChecked}" "${_longName}" \
     || arrayContains "${_flagsAlreadyChecked}" "${_shortName}"; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# txt: Checks the command-line parameters.
# fun: CLI.checkCommandLineParameters parameter*
# opt: parameter: The parameters provided.
# use: CLI.checkCommandLineParameters "/tmp/1.txt" "http://www.example.com";
function CLI.checkCommandLineParameters() {
  local _parameterName;
  local _parameterValue;
  local _parameterNameInUpperCase;
  local -i _callbackDefined;
  local -i _mandatory;
  local -i _multiple;

  # Parameters
  IFS="${DWIFS}";
  for _parameterName in ${__DW_CLI_PARAMETER_NAMES[*]}; do
    IFS="${_oldIFS}";
    _parameterValue="${1}";
    shift;
    if CLI.isCommandLineParameterMandatory "${_parameterName}"; then
      _mandatory=${TRUE};
    else
      _mandatory=${FALSE};
    fi
    if isFunctionDefined "dw_check_${_parameterName}_cli_parameter"; then
      _callbackDefined=${TRUE};
    else
      _callbackDefined=${FALSE};
    fi
    if CLI.isCommandLineParameterMultiple "${_parameterName}"; then
      _multiple=${TRUE};
    else
      _multiple=${FALSE};
    fi
    if isEmpty "${_parameterValue}" && isTrue ${_mandatory}; then
      toUpper "${_parameterName}";
      _parameterNameInUpperCase="${RESULT}";
      exitWithError "${_parameterNameInUpperCase}_IS_MANDATORY" "${_parameterName} is mandatory";
    fi
    if isTrue ${_callbackDefined}; then
      if isTrue ${_multiple}; then
        "dw_check_${_parameterName}_cli_parameter" "${_parameterValue}" ${@};
      else
        "dw_check_${_parameterName}_cli_parameter" "${_parameterValue}";
      fi
    fi
  done
  IFS="${_oldIFS}";
}

# txt: Checks the environment variables.
# fun: CLI.checkEnvironmentVariables
# use: CLI.checkEnvironmentVariables;
function CLI.checkEnvironmentVariables() {
  local _envVars;
  local -i _callbackDefined;
  local _envVarName;
  local _envVarValue;
  local _envVarNameInLowerCase;
  local _oldIFS="${IFS}";

  retrieveCustomEnvironmentVariables;
  _envVars="${RESULT}";

  IFS="${DWIFS}";
  for _envVarName in ${_envVars}; do
    IFS="${_oldIFS}";

    if isEnvVarMandatory "${_envVarName}"; then
      evalVar "${_envVarName}";
      _envVarValue="${RESULT}";
      if isEmpty "${_envVarValue}"; then
        exitWithError "${_envVarName}_IS_MANDATORY" "${_envVarName} environment variable is mandatory";
      fi
    fi

    toLower "${_envVarName}";
    _envVarNameInLowerCase="${RESULT}";
    if isFunctionDefined "dw_check_${_envVarNameInLowerCase}_cli_envvar"; then
      _callbackDefined=${TRUE};
    else
      _callbackDefined=${FALSE};
    fi
    if isTrue ${_callbackDefined}; then
      "dw_check_${_envVarNameInLowerCase}_cli_envvar" "${_envVar}"
    fi
  done
  IFS="${_oldIFS}";
}

# txt: Checks whether given flag is defined.
# txt: Returns 0/TRUE if the flag is defined; 1/FALSE otherwise.
# fun: CLI.isFlagDefined flagKey
# opt: flagKey: The flag key.
# use: if CLI.isFlagDefined "f|file"; then
# use:   echo "f/file is defined";
# use: fi
function CLI.isFlagDefined() {
  local _flagKey="${1}";
  local -i _rescode;

  checkNotEmpty "flagKey" "${_flagKey}" 1;

  arrayContains "${__DW_CLI_FLAG_KEYS[*]}" "${_flagKey}"
  _rescode=$?;

  return ${_rescode};
}

# txt: Builds the name of the callback function used when parsing a flag.
# txt: RESULT will contain the name of the callback function.
# fun: CLI.buildNameOfTheCallbackFunctionToParseFlag longName
# opt: longName: The long name of the flag.
# use: CLI.buildNameOfTheCallbackFunctionToParseFlag "file";
# use: echo "callback function: ${RESULT}";
function CLI.buildNameOfTheCallbackFunctionToParseFlag() {
  local _longName="${1}";

  checkNotEmpty "longName" "${_longName}" 1;

  export RESULT="dw_parse_${_longName}_cli_flag";
}

# txt: Checks whether the callback function to parse given flag (in its long-name version) exists.
# txt: Returns 0/TRUE if the callback function exists; 1/FALSE otherwise.
# fun: CLI.parseCallbackDefinedForFlag longName
# opt: longName: The long name of the flag.
# use: if CLI.parseCallbackDefinedForFlag "file"; then
# use:   echo "The callback function to parse 'file' flag exists";
# use: fi
function CLI.parseCallbackDefinedForFlag() {
  local _longName="${1}";
  local -i _rescode;

  checkNotEmpty "longName" "${_longName}" 1;

  CLI.buildNameOfTheCallbackFunctionToParseFlag "${_longName}";
  isFunctionDefined "${RESULT}";
  _rescode=$?;

  return ${_rescode};
}

# txt: Parses given flag.
# txt: Returns the number of parameters to shift.
# fun: CLI.parseFlag flag remainingArguments
# opt: flag: The flag to parse.
# opt: remainingArguments: The rest of the command-line flags and parameters.
# use: CLI.parseFlag "-f" $@;
# use: echo "Must shift $?";
function CLI.parseFlag() {
  local _flag="${1}";
  shift;
  local -i _result=0;
  local _flagCount;
  local _longName;
  local _shortName;
  local _flagKey;
  local _callbackFunction;
  local -i _continue=${TRUE};

  checkNotEmpty "${_flag}" "flag" 1;

  _flagCount=$((_flagCount+1));
  case ${_flag} in
    --)
      _continue=${FALSE};
      ;;
  esac

  if isTrue ${_continue}; then
    if CLI.retrieveCommandLineFlagLongName "${_flag}"; then
      _longName="${RESULT}";
    else
      exitWithError UNKNOWN_FLAG "Unknown flag ${_flag}";
    fi

    if CLI.retrieveCommandLineFlagShortName "${_flag}"; then
      _shortName="${RESULT}";
    else
      exitWithError UNKNOWN_FLAG "Unknown flag ${_flag}";
    fi

    CLI.buildCommandLineFlagKey "${_shortName}" "${_longName}";
    _flagKey="${RESULT}";

    if CLI.isFlagDefined "${_flagKey}"; then
      if CLI.parseCallbackDefinedForFlag "${_longName}"; then
        CLI.buildNameOfTheCallbackFunctionToParseFlag "${_longName}";
        _callbackFunction="${RESULT}";
        if CLI.doesCommandLineFlagExpectArgument "${_flagKey}"; then
          _argument="${1}";
          _result=$((_result+1));
          "${_callbackFunction}" "${_argument}";
        else
          "${_callbackFunction}";
        fi
      fi
    else
      exitWithError INVALID_OPTION "Unexpected flag: ${_flag}";
    fi
  fi

  return ${_result};
}

# txt: Retrieves the command-line flag key from given flag representation (either long or short).
# txt: Returns 0/TRUE if the flag key was found; 1/FALSE otherwise.
# txt: If the function returs 0/TRUE, the variable RESULT contains the flag key.
# fun: CLI.retrieveFlagKey flag
# opt: flag: The flag.
# use: if CLI.retrieveFlagKey "-f"; then
# use:   echo "flag key: ${RESULT}";
# use: fi
function CLI.retrieveFlagKey() {
  local _flag="${1}";
  local -i _rescode;
  local _longName;
  local _shortName;

  checkNotEmpty "flag" "${_flag}" 1;

  if CLI.retrieveCommandLineFlagLongName "${_flag}"; then
    _longName="${RESULT}";
    if CLI.retrieveCommandLineFlagShortName "${_flag}"; then
      _shortName="${RESULT}";
      CLI.buildCommandLineFlagKey "${_shortName}" "${_longName}";
      # implicit RESULT
      _rescode=${TRUE};
    else
      _rescode=${FALSE};
    fi
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# txt: Performs the parse step for any optional flag not provided.
# txt: Returns 0/TRUE if the process succeeds; 1/FALSE otherwise.
# fun: CLI.parseNotProvidedFlags providedFlags
# opt: providedFlags: The provided flags.
# use: if CLI.parseNotProvidedFlags "-f -v"; then
# use:   echo "Parsing not provided flags succeeded";
# use: fi
function CLI.parseNotProvidedFlags() {
  local _providedFlags="${1}";
  local -a _notProvidedFlags=();
  local _flag;
  local _providedFlag;
  local _longName;
  local _upcasedLongName;
  local _flagKey;
  local -i _rescode;
  local _oldIFS="${IFS}";

  IFS="${DWIFS}";
  for _flagKey in ${__DW_CLI_FLAG_KEYS[*]}; do
    _provided=${FALSE};
    for _providedFlag in ${_providedFlags}; do
      IFS="${_oldIFS}";
      CLI.retrieveCommandLineFlagLongNameFromKey "${_flagKey}";
      _longName="${RESULT}";
      CLI.retrieveCommandLineFlagShortNameFromKey "${_flagKey}";
      _shortName="${RESULT}";
      if    areEqual "${_providedFlag}" "${_longName}" \
         || areEqual "${_providedFlag}" "${_shortName}"; then
        _provided=${TRUE};
        break;
      fi
    done

    IFS="${_oldIFS}";
    if isFalse ${_provided}; then
      if CLI.retrieveDefaultValueForOptionalFlag "${_flagKey}"; then
        _defaultValueDefined=${TRUE};
        _defaultValue="${RESULT}";
      fi
      if isTrue ${_defaultValueDefined}; then
        if CLI.parseCallbackDefinedForFlag "${_longName}"; then
          CLI.buildNameOfTheCallbackFunctionToParseFlag "${_longName}";
          _callbackFunction="${RESULT}";
          "${_callbackFunction}" "${_defaultValue}";
        else
          normalizeUppercase "${_longName}";
          _upcasedLongName="${RESULT}";
          export ${_upcasedLongName}="${_defaultValue}";
        fi
      fi
    fi
  done
  IFS="${_oldIFS}";

  return ${_rescode};
}

# txt: Retrieves the default value for given optional flag.
# txt: Returns 0/TRUE if the default value was defined; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the default value, if it's defined.
# fun: CLI.retrieveDefaultValueForOptionalFlag flagKey
# opt: flagKey: The flag key.
# use: if CLI.retrieveDefalutValueForOptionalFlag "f|file"; then
# use:   echo "f|file -> ${RESULT}";
# use: fi
function CLI.retrieveDefaultValueForOptionalFlag() {
  local _flagKey="${1}";
  local _result;
  local -i _rescode;

  checkNotEmpty "flagKey" "${_flagKey}" 1;

  _result="${__DW_CLI_OPTIONAL_FLAG_DEFAULT_VALUES[${_flagKey}]}";
  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# txt: Parses the command-line parameters.
# fun: CLI.parseCommandLineParameters parameter*
# opt: parameter: The CLI parameters.
# use: CLI.parseCommandLineParameters "/tmp/1.txt" "http://www.example.com"
function CLI.parseCommandLineParameters() {
  local _parameterName;
  local _parameterValue;
  local _oldIFS="${IFS}";

  IFS="${DWIFS}";
  for _parameterName in ${__DW_CLI_PARAMETER_NAMES[*]}; do
    IFS="${_oldIFS}";
    if isFunctionDefined "dw_parse_${_parameterName}_cli_parameter"; then
      if CLI.isCommandLineParameterMultiple "${_parameterName}"; then
        "dw_parse_${_parameterName}_cli_parameter" ${@};
      else
        _parameterValue="${1}";
        shift;
        "dw_parse_${_parameterName}_cli_parameter" "${_parameterValue}";
      fi
    else
      toUpper "${_parameterName}";
      _parameterNameInUpperCase="${RESULT}";
      exitWithError "MISSING_PARSE_FUNCTION_FOR_PARAMETER_${_parameterNameInUpperCase}" "dw_parse_${_parameterName}_cli_parameter function is not defined";
    fi
  done
  IFS="${_oldIFS}";
}

# txt: Builds a key for given command-line flag.
# txt: Returns 0/TRUE if the key was built successfully; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the key.
# fun: CLI.buildCommandLineFlagKey shortName longName
# opt: shortName: The short name of the flag.
# opt: longName: The long name of the flag.
# use: if CLI.buildCommandLineFlagKey "f" "file"; then
# use:   echo "key: ${RESULT}";
# use: fi
function CLI.buildCommandLineFlagKey() {
  local _shortName="${1}";
  local _longName="${2}";
  local -i _rescode=${TRUE};

  checkNotEmpty "shortName" "${_shortName}" 1;
  checkNotEmpty "longName" "${_longName}" 2;

  export RESULT="${_shortName}|${_longName}";

  return ${_rescode};
}

# txt: Retrieves the key of a command-line flag from its short name.
# txt: Returns 0/TRUE if the key was built successfully; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the key.
# fun: CLI.retrieveCommandLineFlagKeyFromShortName shortName
# opt: shortName: The short name of the flag.
# use: if CLI.retrieveCommandLineFlagKeyFromShortName "f"; then
# use:   echo "key: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagKeyFromShortName() {
  local _shortName="${1}";
  local -i _rescode=${TRUE};

  checkNotEmpty "shortName" "${_shortName}" 1;

  if removePrefix "${_shortName}" "-*"; then
    _shortName="${RESULT}";
  fi
  _longName="${__DW_CLI_FLAG_LONG_NAMES[${_shortName}]}";

  if isNotEmpty "${_longName}"; then
    if CLI.buildCommandLineFlagKey "${_shortName}" "${_longName}"; then
      _rescode=${TRUE};
      ## RESULT is passed directly.
    else
      _rescode=${FALSE};
      export RESULT="";
    fi
  else
    _rescode=${FALSE};
    export RESULT="";
  fi

  return ${_rescode};
}

# txt: Retrieves the key of a command-line flag from its long name.
# txt: returns 0/true if the key was built successfully; 1/false otherwise.
# txt: if the function returns 0/true, the variable result contains the key.
# fun: CLI.retrievecommandlineflagkeyfromlongname longname
# opt: longname: the long name of the flag.
# use: if CLI.retrievecommandlineflagkeyfromlongname "file"; then
# use:   echo "key: ${result}";
# use: fi
function CLI.retrieveCommandLineFlagKeyFromLongName() {
  local _longName="${1}";
  local -i _rescode=${true};

  checkNotEmpty "longName" "${_longName}" 1;

  if removePrefix "${_longName}" "-*"; then
    _longName="${RESULT}";
  fi

  _shortName="${__DW_CLI_FLAG_SHORT_NAMES[${_longName}]}";
  if isNotEmpty "${_shortName}"; then
    if CLI.buildCommandLineFlagKey "${_shortName}" "${_longName}"; then
      _rescode=${TRUE};
      ## RESULT is passed directly.
    else
      _rescode=${FALSE};
      export RESULT="";
    fi
  else
    _rescode=${FALSE};
    export RESULT="";
  fi

  return ${_rescode};
}

# txt: Retrieves the short name of given command-line flag key.
# txt: Returns 0/TRUE if the short name was found; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the short name.
# fun: CLI.retrieveCommandLineFlagShortNameFromKey flagKey
# opt: flagKey: The key.
# use: if CLI.retrieveCommandLineFlagShortNameFromKey "f|file"; then
# use:   echo "short name: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagShortNameFromKey() {
  local _key="${1}";
  local _result;
  local -i _rescode;

  checkNotEmpty "key" "${_key}" 1;

  _result="${_key%%|*}";
  if areEqual "${_result}" "${_key}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# txt: Retrieves the long name of given command-line flag key.
# txt: Returns 0/TRUE if the long name was found; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the long name.
# fun: CLI.retrieveCommandLineFlagLongNameFromKey flagKey
# opt: flagKey: The flag key.
# use: if CLI.retrieveCommandLineFlagLongNameFromKey "f|file"; then
# use:   echo "long name: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagLongNameFromKey() {
  local _key="${1}";
  local _result;
  local -i _rescode;

  checkNotEmpty "key" "${_key}" 1;

  _result="${_key##*|}";
  if areEqual "${_result}" "${_key}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# txt: Retrieves the description of given command-line flag key.
# txt: Returns 0/TRUE if the description was found; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the description.
# fun: CLI.retrieveCommandLineFlagDescriptionFromKey flagKey
# opt: flagKey: The flag key.
# use: if CLI.retrieveCommandLineFlagDescriptionFromKey "f|file"; then
# use:   echo "Description: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagDescriptionFromKey() {
  local _key="${1}";
  local _result;
  local -i _rescode;

  checkNotEmpty "key" "${_key}" 1;

  _result="${__DW_CLI_FLAG_DESCRIPTIONS[${_key}]}";
  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# txt: Retrieves the command-line flag flag.
# txt: Returns 0/TRUE if the flag is defined; 1/FALSE otherwise.
# fun: CLI.retrieveCommandLineFlagKey shortOrLongName
# opt: shortOrLongName: The flag (either short or long version).
# use: if CLI.retrieveCommandLineFlagKey "-f"; then
# use:   echo "flag key for -f: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagKey() {
  local _flag="${1}";
  local -i _rescode;

  checkNotEmpty "flag" "${_flag}" 1;

  if CLI.retrieveCommandLineFlagKeyFromShortName "${_flag}"; then
    _rescode=${TRUE};
    ## RESULT gets passed through.
  elif CLI.retrieveCommandLineFlagKeyFromLongName "${_flag}"; then
    _rescode=${TRUE};
    ## RESULT gets passed through.
  else
    _rescode=${FALSE};
    export RESULT="";
  fi

  return ${_rescode};
}

# txt: Check whether a command-line flag is defined already or not.
# txt: Returns 0/TRUE if the flag is defined; 1/FALSE otherwise.
# fun: CLI.isCommandLineFlagDefined shortOrLongName
# opt: shortOrLongName: The flag (either short or long version).
# use: if CLI.isCommandLineFlagDefined "-f"; then
# use:   echo "-f is already defined";
# use: fi
function CLI.isCommandLineFlagDefined() {
  local _flag="${1}";
  local -i _rescode;
  local _flagKey;

  checkNotEmpty "flag" "${_flag}" 1;

  if CLI.retrieveCommandLineFlagKey "${_flag}"; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# txt: Checks whether given flag is mandatory or not.
# txt: Returns 0/TRUE if the flag is mandatory; 1/FALSE otherwise.
# fun: CLI.isCommandLineFlagMandatory flagKey
# opt: flagKey: The flag key.
# use: if CLI.isCommandLineFlagMandatory ${flagKey}"; then
# use:   echo "${flagKey} is mandatory";
# use:  fi
function CLI.isCommandLineFlagMandatory() {
  local _flagKey="${1}";
  local -i _rescode;

  checkNotEmpty "flagKey" "${_flagKey}" 1;

  _value="${__DW_CLI_MANDATORY_FLAGS[${_flagKey}]}";

  if   isEmpty "${_value}" \
    || isTrue "${_value}" \
    || areEqual "${_value}" "${MANDATORY}" \
    || areEqual "${_value}" "MANDATORY"; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# txt: Checks whether given flag expects an argument.
# txt: 0/TRUE if the flag expects an argument; 1/FALSE otherwise.
# fun: CLI.doesCommandLineFlagExpectArgument flagKey
# opt: flagKey: The flag key.
# use: if CLI.doesCommandLineFlagExpectArgument ${flagKey}"; then
# use:   echo "${flagKey} expects an argument";
# use: fi
function CLI.doesCommandLineFlagExpectArgument() {
  local _flagKey="${1}";
  local -i _rescode;

  checkNotEmpty "flagKey" "${_flagKey}" 1;

  _value="${__DW_CLI_FLAG_EXPECTING_ARGUMENTS[${_flagKey}]}";

  if     isEmpty "${_value}" \
      || isTrue "${_value}" \
      || areEqual "${_value}" "${EXPECTS_ARGUMENT}" \
      || areEqual "${_value}" "EXPECTS_ARGUMENT"; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# txt: Retrieves the description of given command-line parameter.
# txt: Returns 0/TRUE if the description was found; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the description.
# fun: CLI.retrieveCommandLineParameterDescriptionFromName paramName
# opt: paramName: The name.
# use: if CLI.retrieveCommandLineParameterDescriptionFromName "project"; then
# use:   echo "Description: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineParameterDescriptionFromName() {
  local _name="${1}";
  local _result;
  local -i _rescode;

  checkNotEmpty "name" "${_name}" 1;

  _result="${__DW_CLI_PARAMETER_DESCRIPTIONS[${_name}]}";
  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# txt: Checks whether given parameter is mandatory or not.
# txt: Returns 0/TRUE if the parameter is mandatory; 1/FALSE otherwise.
# fun: CLI.isCommandLineParameterMandatory paramName
# opt: paramName: The parameter name.
# use: if CLI.isCommandLineParameterMandatory "file"; then
# use:   echo "file is mandatory";
# use: fi
function CLI.isCommandLineParameterMandatory() {
  local _name="${1}";
  local -i _rescode;

  checkNotEmpty "name" "${_name}" 1;

  _value="${__DW_CLI_MANDATORY_PARAMETERS[${_name}]}";

  if    isEmpty "${_value}" \
     || isTrue "${_value}" \
     || areEqual "${_value}" "MANDATORY"; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# txt: Checks whether given parameter is single or not.
# txt: Returns 0/TRUE if the parameter only expects a single value; 1/FALSE otherwise.
# fun: CLI.isCommandLineParameterSingle paramName
# opt: paramName: The parameter name.
# use: if CLI.isCommandLineParameterSingle "file"; then
# use:   echo "file accepts only one value";
# use: fi
function CLI.isCommandLineParameterSingle() {
  local _name="${1}";
  local -i _rescode;

  checkNotEmpty "name" "${_name}" 1;

  _value="${__DW_CLI_SINGLE_PARAMETERS[${_name}]}";

  if    isEmpty "${_value}" \
     || isTrue "${_value}" \
     || areEqual "${_value}" "SINGLE"; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# txt: Checks whether given parameter is multiple or not.
# txt: Returns 0/TRUE if the parameter allows multiple values; 1/FALSE otherwise.
# fun: CLI.isCommandLineParameterMultiple paramName
# opt: paramName: The parameter name.
# use: if CLI.isCommandLineParameterMultiple "file"; then
# use:   echo "file can accept multiple values";
# use: fi
function CLI.isCommandLineParameterMultiple() {
  local _name="${1}";
  local -i _rescode;

  checkNotEmpty "name" "${_name}" 1;

  if CLI.isCommandLineParameterSingle "${_name}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

# txt: Prints a line describing how to run the script.
# txt: Returns 0/TRUE if this function printed anything; 1/FALSE otherwise.
# fun: CLI.commandLineFlagsUsage
# use: if CLI.commandLineFlagsUsage then ... fi
function CLI.commandLineFlagsUsage() {
  local -i _rescode=${TRUE};
  local _message="${SCRIPT_NAME}";
  local _flagKey;
  local _shortName;
  local _longName;
  local _oldIFS="${IFS}";
  local _mandatory;
  IFS=$' \t\n';

  for _flagKey in ${__DW_CLI_FLAG_KEYS[@]}; do
    IFS="${_oldIFS}";
    CLI.retrieveCommandLineFlagShortNameFromKey "${_flagKey}";
    _shortName="${RESULT}";
    CLI.retrieveCommandLineFlagLongNameFromKey "${_flagKey}";
    _longName="${RESULT}";
    _message="${_message} ";
    CLI.isCommandLineFlagMandatory "${_flagKey}";
    _mandatory=$?;
    if isFalse ${_mandatory}; then
      _message="${_message}[";
    fi
    _message="${_message}-${_shortName}|--${_longName}";
    if CLI.doesCommandLineFlagExpectArgument "${_flagKey}"; then
      _message="${_message} arg";
    fi
    if isFalse ${_mandatory}; then
      _message="${_message}]";
    fi
  done
  IFS="${_oldIFS}";

  echo -n "${_message}";

  return ${_rescode};
}

# txt: Conditionally prints (to stdout) a line with the script description.
# txt: Returns 0/TRUE if this function printed anything; 1/FALSE otherwise.
# fun: CLI.scriptDescriptionUsage
# use: if CLI.scriptDescriptionUsage then ... fi
function CLI.scriptDescriptionUsage() {
  local -i _rescode;
  if isEmpty "${__DW_CLI_SCRIPT_DESCRIPTION}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    echo -e "\n${__DW_CLI_SCRIPT_DESCRIPTION}\n";
  fi

  return ${_rescode};
}

# txt: Conditionally prints (to stdout) a line with the license summary.
# txt: Returns 0/TRUE if this function printed anything; 1/FALSE otherwise.
# fun: CLI.scriptLicenseSummaryUsage
# use: if CLI.scriptLicenseSummaryUsage then ... fi
function CLI.scriptLicenseSummaryUsage() {
  local -i _rescode;
  if isEmpty "${__DW_CLI_SCRIPT_LICENSE_SUMMARY}"; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
    echo "${__DW_CLI_SCRIPT_LICENSE_SUMMARY}";
  fi

  return ${_rescode};
}

# txt: Conditionally prints (to stdout) a line with the copyright.
# txt: Returns 0/TRUE if this function printed anything; 1/FALSE otherwise.
# fun: CLI.scriptCopyrightUsage
# use: if CLI.scriptCopyrightUsage then ... fi
function CLI.scriptCopyrightUsage() {
  local -i _rescode;

  if isEmpty "${__DW_CLI_SCRIPT_COPYRIGHT}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    echo "${__DW_CLI_SCRIPT_COPYRIGHT}";
  fi

  return ${_rescode};
}

# txt: Prints a line describing the details of the command-line flags.
# txt: Returns 0/TRUE if this function printed anything; 1/FALSE otherwise.
# fun: CLI.commandLineFlagsDetailedUsage
# use: if CLI.commandLineFlagsDetailedUsage then ... fi
function CLI.commandLineFlagsDetailedUsage() {
  local -i _rescode;
  local _message;
  local _flagKey;
  local _shortName;
  local _longName;
  local _description;
  local _oldIFS="${IFS}";
  IFS=$' \t\n';

  for _flagKey in ${__DW_CLI_FLAG_KEYS[@]}; do
    IFS="${_oldIFS}";
    CLI.retrieveCommandLineFlagShortNameFromKey "${_flagKey}";
    _shortName="${RESULT}";
    CLI.retrieveCommandLineFlagLongNameFromKey "${_flagKey}";
    _longName="${RESULT}";
    CLI.retrieveCommandLineFlagDescriptionFromKey "${_flagKey}";
    _description="${RESULT}";
    _message="${_message}  * -${_shortName}|--${_longName}";
    if CLI.doesCommandLineFlagExpectArgument "${_flagKey}"; then
      _message="${_message} arg";
    fi
    _message="${_message}: ${_description}.";
    if CLI.isCommandLineFlagMandatory "${_flagKey}"; then
      _message="${_message} Mandatory.\n";
    else
      _message="${_message} Optional.\n";
    fi
  done
  IFS="${_oldIFS}";

  if isEmpty "${_message}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    echo -n -e "${_message}";
  fi

  return ${_rescode};
}

# txt: Checks whether given parameter is single or not.
# txt: Returns 0/TRUE if the parameter is single; 1/FALSE otherwise.
# fun: CLI.commandLineParameterIsSingle paramName
# opt: paramName: The parameter name.
# use: if CLI.commandLineParameterIsSingle ${name}"; then
# use:   echo "${name} is multiple";
# use: fi
function CLI.commandLineParameterIsSingle() {
  local _name="${1}";
  local -i _rescode;

  checkNotEmpty "name" "${_name}" 1;

  _value="${__DW_CLI_SINGLE_PARAMETERS[${_name}]}";

  if    isEmpty "${_value}" \
     || isTrue "${_value}" \
     || areEqual "${_value}" "SINGLE"; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# txt: Checks whether given parameter is multiple or not.
# txt: Returns 0/TRUE if the parameter is multiple; 1/FALSE otherwise.
# fun: CLI.commandLineParameterIsMultiple paramName
# opt: paramName: The parameter name.
# use: if CLI.commandLineParameterIsMultiple ${name}"; then
# use:   echo "${name} is multiple";
# use: fi
function CLI.commandLineParameterIsMultiple() {
  local _name="${1}";
  local -i _rescode;

  checkNotEmpty "name" "${_name}" 1;

  if CLI.commandLineParameterIsSingle "${_name}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

# txt: Checks whether given parameter is mandatory or not.
# txt: Returns 0/TRUE if the parameter is mandatory; 1/FALSE otherwise.
# fun: CLI.commandLineParameterIsMandatory paramName
# opt: paramName: The parameter name.
# use: if CLI.commandLineParameterIsMandatory ${name}"; then
# use:   echo "${name} is mandatory";
# use: fi
function CLI.commandLineParameterIsMandatory() {
  local _name="${1}";
  local -i _rescode;

  checkNotEmpty "name" "${_name}" 1;

  _value="${__DW_CLI_MANDATORY_PARAMETERS[${_name}]}";

  if    isEmpty "${_value}" \
      || isTrue "${_value}" \
      || areEqual "${_value}" "MANDATORY"; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# txt: Prints a line describing the script's flags.
# txt: Returns 0/TRUE if this function printed anything; 1/FALSE otherwise.
# fun: CLI.commandLineParametersUsage
# use: if CLI.commandLineParametersUsage then ... fi
function CLI.commandLineParametersUsage() {
  local -i _rescode;
  local _message;
  local _name;
  local _oldIFS="${IFS}";
  local _mandatory;
  IFS=$' \t\n';

  for _name in ${__DW_CLI_PARAMETER_NAMES[@]}; do
    IFS="${_oldIFS}";
    _message="${_message} ${_name}";
    if CLI.commandLineParameterIsMultiple "${_name}"; then
      if CLI.isCommandLineParameterMandatory "${_name}"; then
        _message="${_message}+";
      else
        _message="${_message}*";
      fi
    fi
  done
  IFS="${_oldIFS}";

  if isEmpty "${_message}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    echo -e "${_message}";
  fi

  return ${_rescode};
}

# txt: Prints a line describing the details of the command-line parameters.
# txt: Returns 0/TRUE if this function printed anything; 1/FALSE otherwise.
# fun: CLI.commandLineParametersDetailedUsage
# use: if CLI.commandLineParametersDetailedUsage then ... fi
function CLI.commandLineParametersDetailedUsage() {
  local -i _rescode;
  local _message;
  local _name;
  local _description;
  local _oldIFS="${IFS}";
  IFS=$' \t\n';

  for _name in ${__DW_CLI_PARAMETER_NAMES[@]}; do
    IFS="${_oldIFS}";
    if isNotEmpty "${_message}"; then
      _message="\n";
    fi
    CLI.retrieveCommandLineParameterDescriptionFromName "${_name}";
    _description="${RESULT}";
    _message="${_message}  * ${_name}";
    if CLI.commandLineParameterIsMultiple "${_name}"; then
      _message="${_message}*";
    fi
    _message="${_message}: ${_description}.";
    if CLI.commandLineParameterIsMandatory "${_name}"; then
      _message="${_message} Mandatory.";
    else
      _message="${_message} Optional.";
    fi
  done
  IFS="${_oldIFS}";

  if isEmpty "${_message}"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
    echo -e "${_message}";
  fi

  return ${_rescode};
}

# txt: Sets up the default state.
# txt: Returns 0/TRUE always.
# fun: CLI.defaultState
# use: CLI.defaultState
function CLI.defaultState() {
  ## Built-in flags.
  addCommandLineFlag "debug" "v" "Display debug messages" OPTIONAL NO_ARGUMENT;
  addCommandLineFlag "trace" "vv" "Display trace messages" OPTIONAL NO_ARGUMENT;
  addCommandLineFlag "quiet" "q" "Be silent" OPTIONAL NO_ARGUMENT;
  addCommandLineFlag "help" "h" "Display information about how to use the script" OPTIONAL NO_ARGUMENT;
}

# txt: Resets the module state.
# txt: Returns 0/TRUE always.
# fun: CLI.resetState
# use: CLI.resetState
function CLI.resetState() {
  __DW_CLI_FLAG_KEYS=();
  clearAssociativeArray __DW_CLI_FLAG_LONG_NAMES;
  clearAssociativeArray __DW_CLI_FLAG_SHORT_NAMES;
  clearAssociativeArray __DW_CLI_MANDATORY_FLAGS;
  clearAssociativeArray __DW_CLI_FLAG_EXPECTING_ARGUMENTS;
  clearAssociativeArray __DW_CLI_FLAG_DESCRIPTIONS;
  clearAssociativeArray __DW_CLI_OPTIONAL_FLAG_DEFAULT_VALUES;
  __DW_CLI_PARAMETER_NAMES=();
  clearAssociativeArray __DW_CLI_PARAMETER_DESCRIPTIONS;
  clearAssociativeArray __DW_CLI_MANDATORY_PARAMETERS;
  clearAssociativeArray __DW_CLI_SINGLE_PARAMETERS;
  __DW_CLI_SCRIPT_DESCRIPTION="";
  __DW_CLI_SCRIPT_COPYRIGHT="";
  __DW_CLI_SCRIPT_LICENSE_SUMMARY="";
}

declare -ag __DW_CLI_FLAG_KEYS;
declare -Ag __DW_CLI_FLAG_LONG_NAMES;
declare -Ag __DW_CLI_FLAG_SHORT_NAMES;
declare -Ag __DW_CLI_MANDATORY_FLAGS;
declare -Ag __DW_CLI_FLAG_EXPECTING_ARGUMENTS;
declare -Ag __DW_CLI_FLAG_DESCRIPTIONS;
declare -Ag __DW_CLI_OPTIONAL_FLAG_DEFAULT_VALUES;
declare -ag __DW_CLI_PARAMETER_NAMES;
declare -Ag __DW_CLI_PARAMETER_DESCRIPTIONS;
declare -Ag __DW_CLI_MANDATORY_PARAMETERS;
declare -Ag __DW_CLI_SINGLE_PARAMETERS;
declare -g __DW_CLI_SCRIPT_DESCRIPTION;
declare -g __DW_CLI_SCRIPT_COPYRIGHT;
declare -g __DW_CLI_SCRIPT_LICENSE_SUMMARY;

CLI.resetState;
CLI.defaultState;
