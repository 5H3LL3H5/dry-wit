if [ -z ${ENV_VARIABLES+x} ]; then
  declare -a ENV_VARIABLES;
fi

if [ -z ${OVERRIDEN_ENV_VARIABLES+x} ]; then
  declare -A OVERRIDDEN_ENV_VARIABLES;
fi

if [ -z ${ENVIRONMENT_VARIABLES_DEFAULTS+x} ]; then
  declare -A ENVIRONMENT_VARIABLES_DEFAULTS;
fi

if [ -z ${ENVIRONMENT_VARIABLES_DESCRIPTIONS+x} ]; then
  declare -A ENVIRONMENT_VARIABLES_DESCRIPTIONS;
fi

if [ -z ${ENVIRONMENT_VARIABLES_COMMANDS+x} ]; then
  declare -A ENVIRONMENT_VARIABLES_COMMANDS;
fi

# Bash: Passing variables by reference
# Copyright (C) 2010 Freddy Vulto
# Version: upvars-0.9.dev
# See: http://fvue.nl/wiki/Bash:_Passing_variables_by_reference
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Assign variable one scope above the caller
# Usage: local "$1" && upvar $1 "value(s)"
# Param: $1  Variable name to assign value to
# Param: $*  Value(s) to assign.  If multiple values, an array is
#            assigned, otherwise a single value is assigned.
# NOTE: For assigning multiple variables, use 'upvars'.  Do NOT
#       use multiple 'upvar' calls, since one 'upvar' call might
#       reassign a variable to be used by another 'upvar' call.
# Example:
#
#    f() { local b; g b; echo $b; }
#    g() { local "$1" && upvar $1 bar; }
#    f  # Ok: b=bar
#
function upvar() {
    if unset -v "$1"; then           # Unset & validate varname
        if (( $# == 2 )); then
            eval $1=\"\$2\"          # Return single value
        else
            eval $1=\(\"\${@:2}\"\)  # Return array
        fi
    fi
}


# Assign variables one scope above the caller
# Usage: local varname [varname ...] &&
#        upvars [-v varname value] | [-aN varname [value ...]] ...
# Available OPTIONS:
#     -aN  Assign next N values to varname as array
#     -v   Assign single value to varname
# Return: 1 if error occurs
# Example:
#
#    f() { local a b; g a b; declare -p a b; }
#    g() {
#        local c=( foo bar )
#        local "$1" "$2" && upvars -v $1 A -a${#c[@]} $2 "${c[@]}"
#    }
#    f  # Ok: a=A, b=(foo bar)
#
function upvars() {
  local _flag="${1}";

  if isEmpty "${_flag}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'name' (1) is mandatory in '${FUNCNAME[0]}'. Review ${FUNCNAME[1]}";
  fi

  while (( $# )); do
    case $1 in
      -a*)
        # Error checking
        [[ ${1#-a} ]] || { echo "bash: ${FUNCNAME[0]}: \`$1': missing"\
                                "number specifier" 1>&2; return 1; }
        printf %d "${1#-a}" &> /dev/null || { echo "bash:"\
                                                   "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2
                                              return 1; }
        # Assign array of -aN elements
        [[ "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && \
          shift $((${1#-a} + 2)) || { exitWithErrorCode UNACCEPTABLE_API_CALL "\`$1${2+ }$2': missing argument(s) to ${FUNCNAME[0]}. Review ${FUNCNAME[1]}"; }
        ;;
      -v)
        # Assign single value
        [[ "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && \
          shift 3 || { exitWithErrorCode UNACCEPTABLE_API_CALL "$1: missing argument(s) to ${FUNCNAME[0]}. Review ${FUNCNAME[1]}"; }
        ;;
      --help) echo "\
Usage: local varname [varname ...] &&
   ${FUNCNAME[0]} [-v varname value] | [-aN varname [value ...]] ...
Available OPTIONS:
-aN VARNAME [value ...]   assign next N values to varname as array
-v VARNAME value          assign single value to varname
--help                    display this help and exit
--version                 output version information and exit"
              return 0 ;;
      --version) echo "\
${FUNCNAME[0]}-0.9.dev
Copyright (C) 2010 Freddy Vulto
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law."
                 return 0 ;;
      *)
        exitWithErrorCode UNACCEPTABLE_API_CALL "$1: invalid option to ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
    esac
  done
}

# PRIVATE
# Retrieves the value of given variable.
# -> 1: The variable name.
# <- RESULT: The variable value.
function _evalVar() {
  local _varName="${1}";
  local -i rescode;

  checkNotEmpty "varName" "${_varName}" 1;

  local result="$(set noglob; export DOLLAR='$'; export DQUOTE="\""; echo "echo ${DQUOTE}${DOLLAR}{$(echo "${_varName}")}${DQUOTE}" | sh 2> /dev/null)";
  rescode=$?;
  if isTrue ${rescode}; then
      export RESULT="${result}";
  fi

  return ${rescode};
}

# PUBLIC
# Declares a new environment variable.
# -> 1: The variable name.
# -> 2: The variable description (optional).
# -> 3: The default value (optional).
# -> 4: The command to retrieve the actual value (optional).
function defineEnvVar() {
  local _varName="${1}";
  local _varDescription="${2}";
  local _varDefault="${3}";
  local _varCommand="${4:-}";
  local _upcasedVarName;
  local _varValue;
  local _defaultValue;
  local _description;
  local _command;

  checkNotEmpty "name" "${_varName}" 1;
  checkNotEmpty "description" "${_varDescription}" 2;

  toUpper "${_varName}";
  _upcasedVarName="${RESULT}";

  if _evalVarDescription "${_upcasedVarName}"; then
      _description="${RESULT}";
  fi

  if isEmpty "${_description}"; then
    _addEnvVarDescription "${_upcasedVarName}" "${_varDescription}";
  fi

  if isNotEmpty "${_varDefault}"; then
    _addEnvVarDefault "${_upcasedVarName}" "${_varDefault}";
    if _evalVarDefault "${_upcasedVarName}"; then
      _defaultValue="${RESULT}";

      _evalVar "${_upcasedVarName}";
      _varValue="${RESULT}";

      if isEmpty "${_varValue}"; then
        if isNotEmpty "${_defaultValue}"; then
          _varValue="${_defaultValue}";
        elif isNotEmpty "${_varCommand}"; then
          _addEnvVarCommand "${_upcasedVarName}" "${_varCommand}";
          if _evalVarCommand "${_upcasedVarName}"; then
            _varValue="${RESULT}";
          fi
        fi
      else
        appendEnvVariable "${_upcasedVarName}";
      fi
    fi
  fi

  if isNotEmpty "${_varValue}"; then
    _addEnvVar "${_upcasedVarName}" "${_varValue}";
  fi

  return ${TRUE};
}

# PUBLIC
# Overrides the value of an environment variable.
# -> 1: The variable name.
# -> 2: The variable value.
# -> 3: The variable description (optional).
function overrideEnvVar() {
  local _varName="${1}";
  local _varValue="${2}";
  local _varDescription="${3:-not provided}";
  local _upcasedVarName;

  checkNotEmpty "varName" "${_varName}" 1;

  if isEnvVarDefined ${_varName}; then
    toUpper "${_varName}";
    _upcasedVarName="${RESULT}";
    _addOverriddenEnvVar "${_upcasedVarName}" "${_varValue}";
  fi
  defineEnvVar "${_varName}" "${_varDescription}" "${_varValue}";

  return ${TRUE};
}

## PUBLIC
## Defines an environment variable, if it's not already defined.
## -> 1: the variable name.
## -> 2: The variable description.
## -> 3: The default value.
## -> 4: An optional command to provide the variable value at runtime.
## Example:
##   if defineButDoNotOverrideEnvVar "MY_VAR" "MY_VAR is used for this and that" "dummy";
##      echo "MY_VAR defined";
##   else
##      echo "MY_VAR already defined. Not overridden"
##   fi
function defineButDoNotOverrideEnvVar() {
  local _varName="${1}";
  local _varDescription="${2}";
  local _varDefault="${3}";
  local _varCommand="${4}";
  local -i rescode;

  checkNotEmpty "name" "${_varName}" 1;
  checkNotEmpty "description" "${_varDescription}" 2;

  if isEnvVarDefined ${_varName}; then
      logTrace -n "Skipping already-defined ${_varName}";
      logTraceResult SUCCESS "skipped";
      rescode=${TRUE};
  else
    defineEnvVar "${_varName}" "${_varDescription}" "${_varDefault}" "${_varCommand}";
    rescode=$?;
  fi

  return ${rescode};
}

# PRIVATE
# Annotates given environment variable.
# -> 1: The variable name.
# -> 2: The value.
function _addEnvVar() {
  local _varName="${1}";
  local _varValue="${2:-}";

  checkNotEmpty "varName" "${_varName}" 1;

  if ! isEnvVarDefined "${_varName}"; then
    appendEnvVariable ${_varName} ENV_VARIABLES;
  fi
  upvar "${_varName}" "${_varValue}";

  export "${_varName}"="${_varValue}";
}

# PRIVATE
# Annotates given environment variable as overridden.
# -> 1: The variable name.
# -> 2: The value.
function _addOverriddenEnvVar() {
  local _varName="${1}";
  local _varValue="${2:-}";

  checkNotEmpty "varName" "${_varName}" 1;

  if isEnvVarDefined "${_varName}"; then
      OVERRIDDEN_ENV_VARIABLES["${_varName}"]="${_varValue}";
      _addEnvVar "${_varName}" "${_varValue}";
  fi
}

# PRIVATE
# Annotates the description of given environment variable.
# -> 1: The variable name.
# -> 2: The description.
function _addEnvVarDescription() {
  local _varName="${1}";
  local _varDescription="${2}";

  checkNotEmpty "name" "${_varName}" 1;
  checkNotEmpty "description" "${_varDescription}" 1;

  ENVIRONMENT_VARIABLES_DESCRIPTIONS["${_varName}"]="${_varDescription}";
}

# PRIVATE
# Annotates the default value of given environment variable.
# -> 1: The variable name.
# -> 2: The default value.
function _addEnvVarDefault() {
  local _varName="${1}";
  local _varDefault="${2}";

  checkNotEmpty "name" "${_varName}" 1;
  checkNotEmpty "default" "${_varDefault}" 1;

  ENVIRONMENT_VARIABLES_DEFAULTS["${_varName}"]="${_varDefault}";
}

# PRIVATE
# Annotates the command of given environment variable.
# -> 1: The variable name.
# -> 2: The command.
function _addEnvVarCommand() {
  local _varName="${1}";
  local _varCommand="${2}";

  checkNotEmpty "name" "${_varName}" 1;
  checkNotEmpty "command" "${_varCommand}" 1;

  ENVIRONMENT_VARIABLES_COMMANDS[${_varName}]="${_varCommand}";
}

# Checks whether giver variable is defined.
# -> 1: The variable name.
# <- 0/${TRUE} if the variable is defined; 1/${FALSE} otherwise.
function isEnvVarDefined() {
  local _varName="${1}";
  local e;
  local rescode=${FALSE};

  checkNotEmpty "varName" "${_varName}" 1;

#  echo "Callee: ${FUNCNAME[1]}"
#  echo "var -> ${_varName}";
#  echo -n "val -> ";
#  echo "echo \${${_varName}}" | bash;
  echo "echo \${${_varName}:?no}" | bash > /dev/null 2>&1;
  rescode=$?;

#  if isTrue ${rescode}; then
#      echo "${_variable} already defined";
#      exit 1;
#  fi

#  local _oldIFS="${IFS}";
#  IFS=$' \t\n';
##  set +o nounset
#  local _e;
#  for _e in ${#ENV_VARIABLES[@]}; do
#    if [[ "${e}" == "${_varName}" ]]; then
#      rescode=${TRUE};
#      break;
#    fi
#  done
#  # TODO set -o nounset
#  IFS="${_oldIFS}";

  return ${rescode};
}

# Removes the ${..} envelope.
# -> 1: The variable name.
# <- 0/${TRUE} if the envelope was removed; 1/${FALSE} otherwise.
# <- RESULT: the variable name, without envelope, if existed. Unset otherwise.
# Example:
#  if _removeDollarSquareBrackets '${_bla}'; then
#    echo "result -> ${RESULT}" # _bla
#  fi
function _removeDollarSquareBrackets() {
  local _varName="${1}";
  local -i rescode;
  local result;

  if [ "${_varName#$\{}" == "${_varName}" ]; then
      rescode=${FALSE};
  elif [ "${_varName%\}}" == "${_varName}" ]; then
      rescode=${FALSE};
  else
    rescode=${TRUE};
    result="${_varName#$\{}";
    result="${result%\}}";
    export RESULT="${result}";
  fi
  return ${rescode};
}

# Evaluates given environment variable.
# -> 1: the variable name.
function _evalEnvVar() {
  local _varName="${1}";
  local -i rescode;

  checkNotEmpty "varName" "${_varName}" 1;

  if _removeDollarSquareBrackets "${_varName}"; then
      _evalEnvVar "${RESULT}";
  else
    _evalVarDefault "${_varName}";
    local _defaultValue="${RESULT}";
    _evalVar "${_varName}";
    local _varValue="${RESULT}";

    if isEmpty "${_varValue}"; then
        if isNotEmpty "${DRY_WIT_EVAL_DEFAULTS_FLAG}" ; then
            #      echo -n "Evaluating ${_varName}_DEFAULT_COMMAND -> ";
            _evalVarCommand "${_varName}";
            local _defaultCommand="${RESULT}";
            #      echo "${_defaultCommand}";
            if isNotEmpty "${_defaultCommand}"; then
                logTrace -n "Resolving ${_varName}_DEFAULT via ${_varName}_DEFAULT_COMMAND"
                local _aux="$(set noglob; echo "${_defaultCommand}" | sh)";
                if isNotEmpty "${_aux}"; then
                    _defaultValue="${_aux}";
                    logTraceResult SUCCESS "${_aux}"
                else
                  logTraceResult FAILURE "${_DW_FAILED}"
                fi
            fi
        fi
        _varValue="${_defaultValue}";
    fi

    if isNotEmpty ${_varValue} && isEmpty "${DRY_WIT_EVAL_DEFAULTS_FLAG}"; then
        while [[ "${_varValue}" =~ .*'$'.* ]]; do
          _varValue="$(set noglob; echo "echo ${_varValue}" | sh)";
        done
    fi

    if isNotEmpty "${_varValue}"; then
        export ${_varName}="${_varValue}" 2> /dev/null;
        export RESULT="${_varValue}";
        rescode=${TRUE};
    else
      rescode=${FALSE};
    fi
  fi

  return ${rescode};
}

function evalEnvVars() {
  local _oldIFS="${IFS}";
  local var;
  IFS=$' \t\n';
  for var in "${ENV_VARIABLES[@]}"; do
    _evalEnvVar ${var};
  done
  IFS="${_oldIFS}";
}

## Evaluates given overridden variable.
## -> 1: The overridden variable.
## <- 0/${TRUE} if the variable is indeed overridden; 1/${FALSE} otherwise.
## <- RESULT: The value of the overridden variable.
## Example:
##   if _evalOverriddenVar "myVar"; then
##     echo "myVar -> ${RESULT}";
##   fi
function _evalOverriddenVar() {
  local _varName="${1}";
  local result;
  local -i rescode;

  checkNotEmpty "name" "${_varName}" 1;

  result="${OVERRIDDEN_ENV_VARIABLES[${_varName}]}";
  if isEmpty "${result}"; then
      rescode=${FALSE};
  else
    export RESULT="${result}";
    rescode=${TRUE};
  fi

  return ${rescode};
}

## Retrieves the variable description.
## -> 1: The variable name.
## <- 0/${TRUE} if the variable description is defined; 1/${FALSE} otherwise.
## <- RESULT: The variable description.
## Example:
##   if _evalVarDescription "myVar"; then
##     echo "myVar -> ${RESULT}";
##   fi
function _evalVarDescription() {
  local _varName="${1}";
  local result;
  local -i rescode;

  checkNotEmpty "name" "${_varName}" 1;

  result="${ENVIRONMENT_VARIABLES_DESCRIPTIONS[${_varName}]}";
  if isEmpty "${result}"; then
      rescode=${FALSE};
  else
    export RESULT="${result}";
    rescode=${TRUE};
  fi

  return ${rescode};
}

## Retrieves the default value for given variable.
## -> 1: The variable name.
## <- 0/${TRUE} if the default value is defined; 1/${FALSE} otherwise.
## <- RESULT: The default value..
## Example:
##   if _evalVarDefault "myVar"; then
##     echo "myVar -> ${RESULT}";
##   fi
function _evalVarDefault() {
  local _varName="${1}";
  local result;
  local -i rescode;

  checkNotEmpty "name" "${_varName}" 1;

  result="${ENVIRONMENT_VARIABLES_DEFAULTS[${_varName}]}";
  if isEmpty "${result}"; then
      rescode=${FALSE};
  else
    export RESULT="${result}";
    rescode=${TRUE};
  fi

  return ${rescode};
}

## Retrieves the command defined to retrieve a variable's default value.
## -> 1: The variable name.
## <- 0/${TRUE} if the command is defined; 1/${FALSE} otherwise.
## <- RESULT: The command.
## Example:
##   if _evalVarCommand "myVar"; then
##     echo "myVar -> ${RESULT}";
##   fi
function _evalVarCommand() {
  local _varName="${1}";
  local result;
  local -i rescode;

  checkNotEmpty "name" "${_varName}" 1;

  result="${ENVIRONMENT_VARIABLES_COMMANDS[${_varName}]}";
  if isEmpty "${result}"; then
      rescode=${FALSE};
  else
    export RESULT="${result}";
    rescode=${TRUE};
  fi

  return ${rescode};
}


## Appends a new variable to ENV_VARIABLES.
## -> 1: The item to add.
##
## Example:
##   appendEnvVariable "item";
function appendEnvVariable() {
  local _variable="${1}";

  if declare -p ENV_VARIABLES > /dev/null 2>&1; then
    upvars -a$((${#ENV_VARIABLES[@]}+1)) ENV_VARIABLES "${ENV_VARIABLES[@]}" "${_variable}";
    export ENV_VARIABLES;
  else
    export -a ENV_VARIABLES=();
    upvars -a1 ENV_VARIABLES "${_variable}";
    export ENV_VARIABLES;
  fi
}

## Prints the environment variables.
## Example:
##   printEnvironment;
function printEnvironment() {
  local -i i=0;
  local _varName;
  local _varValue;
  local _description;
  local _tempFile;

  if isNotEmpty "${ENV_VARIABLES}" && isTraceEnabled; then
    cat <<EOF
Environment variables:
EOF
    if createTempFileNoCleanup; then
        _tempFile="${RESULT}";
    fi

    local _oldIFS="${IFS}";
    IFS=$' \t\n';
    for ((i = 0; i < ${#ENV_VARIABLES[@]}; i++)); do
      _varName="${ENV_VARIABLES[$i]}";
      if _evalOverriddenVar "${_varName}"; then
          _varValue="${RESULT}";
      else
        _evalVar "${_varName}";
        _varValue="${RESULT}";
      fi
      if _evalVarDescription "${_varName}"; then
          _description=": ${RESULT}.";
      else
        _description="";
      fi
      if isEmpty "${_tempFile}"; then
          echo "  ${_varName} (${_varValue})${_description}";
      else
        echo "  ${_varName} (${_varValue})${_description}" >> "${_tempFile}";
      fi
    done
    IFS="${_oldIFS}";

    if isNotEmpty "${_tempFile}"; then
        cat "${_tempFile}" | sort;
        rm -f "${_tempFile}" > /dev/null 2>&1;
    fi
  fi
}

function reset_state() {
  ENV_VARIABLES=();
  OVERRIDDEN_ENV_VARIABLES=();
  ENVIRONMENT_VARIABLES_DEFAULTS=();
  ENVIRONMENT_VARIABLES_DESCRIPTIONS=();
  ENVIRONMENT_VARIABLES_COMMANDS=();
}