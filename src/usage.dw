import error;

function _printEnvironment() {
  local -i i=0;
  local _varName;
  local _varValue;
  local _description;
  local _tempFile;

  if isNotEmpty "${ENV_VARIABLES}" && isTraceEnabled; then
    cat <<EOF
Environment variables:
EOF
    if createTempFileNoCleanup; then
        _tempFile="${RESULT}";
    fi

    local _oldIFS="${IFS}";
    IFS=$' \t\n';
    for ((i = 0; i < ${#ENV_VARIABLES[@]}; i++)); do
      _varName="${ENV_VARIABLES[$i]}";
      if _evalOverriddenVar "${_varName}"; then
          _varValue="${RESULT}";
      else
        _evalVar "${_varName}";
        _varValue="${RESULT}";
      fi
      if _evalVarDescription "${_varName}"; then
          _description=": ${RESULT}.";
      else
        _description="";
      fi
      if isEmpty "${_tempFile}"; then
          echo "  ${_varName} (${_varValue})${_description}";
      else
        echo "  ${_varName} (${_varValue})${_description}" >> "${_tempFile}";
      fi
    done
    IFS="${_oldIFS}";

    if isNotEmpty "${_tempFile}"; then
        cat "${_tempFile}" | sort;
        rm -f "${_tempFile}" > /dev/null 2>&1;
    fi
  fi
}

function _printExitValues() {
  local -i i=0;
  local -i j=0;

  if isTraceEnabled; then
    cat <<EOF
Exit values:
  0: No error.
EOF
    local _oldIFS="${IFS}";
    IFS=$' \t\n';
    if [ ${#BUILTIN_ERRORS[@]} -gt 0 ]; then
      for ((i = 0; i < ${#BUILTIN_ERRORS[@]}; i++)); do
        echo "  $((i+1)): $(echo ${BUILTIN_ERRORS[$i]} | awk -v dollar="$" '{printf("echo %s{%s}\n", dollar, $0);}' | sh).";
      done
    fi
    if [ ${#ERROR_MESSAGES[@]} -gt 0 ]; then
      for ((j = 0; j < ${#ERROR_MESSAGES[@]}; j++)); do
        echo "  $((j+i+1)): $(echo ${ERROR_MESSAGES[$j]} | awk -v dollar="$" '{printf("echo %s{%s}\n", dollar, $0);}' | sh).";
      done
    fi
    IFS="${_oldIFS}";
  fi
}

function _printHelp() {

  if _functionPresent defineEnv "${SCRIPT_NAME}"; then
    defineEnv;
  fi
  usage $SCRIPT_NAME;
  _printEnvironment;
  _printExitValues;
}

function _printUsage() {
  _printHelp >&2
}
