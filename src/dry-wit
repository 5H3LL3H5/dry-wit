#!/bin/bash
# (c) 2008-today Automated Computing Machinery, S.L.
#
#    This file is part of dry-wit.
#
#    dry-wit is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    dry-wit is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with dry-wit.  If not, see <http://www.gnu.org/licenses/>.
# mod: bootstrap
# api: private
# txt: Bootstrap functions.

#set -o errexit  # terminate on any unhandled error
#set -o nounset  # terminate on any unset variable
set -o pipefail # In a pipe, the exit status of the last command that threw a non-zero exit code is returned.
#set -o xtrace   # trace what gets executed

if [ "${SKIP_LOADING_DRY_WIT}" != "" ]; then
  return;
fi

# fun: DW.nested
# api: private
# txt: Checks whether this script is running within another dry-wit script.
# txt: Returns 0/TRUE if this script is nested within another dry-wit; 1/FALSE otherwise.
# use: if DW.nested; then echo "Nesting detected"; fi
function DW.nested() {
  local -i _rescode=${TRUE};

  if [ -z ${SCRIPT_INDEX+x} ]; then
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# fun: DW.declareGlobalInt
# api: public
# txt: Declares a global integer variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The name of the variable.
# opt: value: The initial value. Optional.
# txt: Returns 0/TRUE if the variable gets declared; 1/FALSE it already exists.
# txt: The variable RESULT contains the new or the existing global variable name.
# use: if DW.declareGlobalInt "LOGGING" "ONE_THOUSAND" 1000; then echo "ONE_THOUSAND variable name: ${RESULT}"; fi
function DW.declareGlobalInt() {
  local _module="${1}";
  checkNotEmpty module "${_module}" 1;
  local _varName="${2}";
  checkNotEmpty varName "${_varName}" 2;
  local _value="${3}";

  DW.declareGlobalVariable "${_module}" "${_varName}" "int" "${_value}";
}

# fun: DW.getGlobalIntValue
# api: public
# txt: Retrieves the value of a global integer variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The name of the variable.
# txt: Returns 0/TRUE if the variable exists; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the variable value.
# use: if DW.getGlobalIntValue "LOGGING" "ONE_THOUSAND"; then echo "ONE_THOUSAND=${RESULT}"; fi
function DW.getGlobalIntValue() {
  local _module="${1}";
  checkNotEmpty module "${_module}" 1;
  local _varName="${2}";
  checkNotEmpty varName "${_varName}" 2;
  local -i _rescode=${FALSE};
  local _result;

  if DW.getGlobalStringValue "${_module}" "${_varName}" "${_value}"; then
    _result="${RESULT}";
    _rescode=${TRUE};
  fi

  if [ ${_rescode} -eq 0 ]; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: DW.declareGlobalArray
# api: public
# txt: Declares a global array variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The name of the variable.
# opt: values*: The initial values. Optional.
# txt: Returns 0/TRUE if the variable gets declared; 1/FALSE it already exists.
# txt: The variable RESULT contains the new or the existing global variable name.
# use: if DW.declareGlobalArray "LOGGING" "MY_LIST" "a" "b" "c"; then echo "MY_LIST variable name: ${RESULT}"; fi
function DW.declareGlobalArray() {
  local _module="${1}";
  checkNotEmpty module "${_module}" 1;
  local _varName="${2}";
  checkNotEmpty varName "${_varName}" 2;
  shift;
  shift;
  local _values="${@}";
  DW.declareGlobalVariable "${_module}" "${_varName}" "array" ${_values};
}

# fun: DW.declareGlobalString
# api: private
# txt: Declares a global String variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The name of the variable.
# opt: value: The initial value. Optional.
# txt: Returns 0/TRUE if the variable gets declared; 1/FALSE it already exists.
# txt: The variable RESULT contains the new or the existing global variable name.
# use: if DW.declareGlobalString "LOGGING" "MY_STRING" "test"; then echo "MY_STRING variable name: ${RESULT}"; fi
function DW.declareGlobalString() {
  local _module="${1}";
  checkNotEmpty module "${_module}" 1;
  local _varName="${2}";
  checkNotEmpty varName "${_varName}" 2;
  local _value="${3}";

  DW.declareGlobalVariable "${_module}" "${_varName}" "string" "${_value}";
}

# fun: DW.getGlobalStringValue
# api: public
# txt: Retrieves the value of a global String variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The name of the variable.
# txt: Returns 0/TRUE if the variable exists; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the variable value.
# use: if DW.getGlobalStringValue "LOGGING" "MY_STRING"; then echo "MY_STRING=${RESULT}"; fi
function DW.getGlobalStringValue() {
  local _module="${1}";
  checkNotEmpty module "${_module}" 1;
  local _varName="${2}";
  checkNotEmpty varName "${_varName}" 2;
  local -i _rescode=${FALSE};
  local _result;

  if DW.getGlobalVariableName "${_module}" "${_varName}"; then
    local -n _aux="${RESULT}";
    _result="${_aux}";
    _rescode=${TRUE};
  fi

  if [ ${_rescode} -eq 0 ]; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: DW.declareGlobalVariable
# api: public
# txt: Declares a global variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The name of the variable.
# opt: varType: Either "int", "array" or "string".
# opt: initialValue: The initial value. Optional.
# txt: Returns 0/TRUE if the variable gets declared; 1/FALSE it already exists.
# txt: The variable RESULT contains the new or the existing global variable name.
# use: if DW.declareGlobalVariable "LOGGING" "MY_LIST" "array"; then echo "MY_LIST variable name: ${RESULT}"; fi
function DW.declareGlobalVariable() {
  local _module="${1}";
  checkNotEmpty module "${_module}" 1;
  local _varName="${2}";
  checkNotEmpty varName "${_varName}" 2;
  local _varType="${3}";
  checkNotEmpty varType "${_varType}" 3;
  local _initialValue="${4}";
  shift;
  shift;
  shift;
  local _initialValues="${@}";
  local -i _rescode;

  BOOTSTRAP.toUpper "${_module}";
  local _moduleUpcased="${RESULT}";

  BOOTSTRAP.toUpper "${_varName}";
  local _varNameUpcased="${RESULT}";

  local _aux="_DW_${_moduleUpcased}_${_varNameUpcased}";

  if DW.nested; then
    _aux="${_aux}_${SCRIPT_INDEX}";
  fi

  if [ -n "${!_aux}" ]; then
    _rescode=${FALSE};
  else
    case "${_varType}" in
      "int") if BOOTSTRAP.failsafeIsEmpty "${_initialValue}"; then
               declare -agx "${_aux}";
             else
               declare -agx "${_aux}"=${_initialValue};
             fi
             _rescode=$?;
             ;;
      "array") if BOOTSTRAP.failsafeIsEmpty "${_initialValues}"; then
                 eval "declare -agx ${_aux}=();";
               else
                 eval "declare -agx ${_aux}=( ${_initialValues} );";
               fi
               _rescode=$?;
               ;;
      *) if BOOTSTRAP.failsafeIsEmpty "${_initialValue}"; then
           declare -gx "${_aux}";
         else
           declare -gx "${_aux}"="${_initialValue}";
         fi
         _rescode=$?;
         ;;
    esac
  fi

  return ${_rescode};
}

# fun: DW.getGlobalVariableName
# api: public
# txt: Retrieves the name of a global variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The (logical) name of the variable.
# txt: Returns 0/TRUE if the variable exists; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the name of the existing global variable.
# use: if DW.getGlobalVariableName "LOGGING" "MY_LIST"; then local -n _var="${RESULT}"; fi
function DW.getGlobalVariableName() {
  local _module="${1}";
  checkNotEmpty module "${_module}" 1;
  local _varName="${2}";
  checkNotEmpty varName "${_varName}" 2;
  local -i _rescode;

  BOOTSTRAP.toUpper "${_module}";
  local _moduleUpcased="${RESULT}";

  BOOTSTRAP.toUpper "${_varName}";
  local _varNameUpcased="${RESULT}";

  local _result="_DW_${_moduleUpcased}_${_varNameUpcased}";

  if DW.nested; then
    _result="${_result}_${SCRIPT_INDEX}";
  fi

  if [ -n "${!_result}" ]; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  if [ ${_rescode} -eq 0 ]; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: DW.getScriptName
# api: public
# txt: Retrieves the name of the script.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the script.
# use: DW.getScriptName; echo "Script name: ${RESULT}";
function DW.getScriptName() {
  DW.getGlobalStringValue DRYWIT SCRIPT_NAME;
}

# fun: DW.getScriptPath
# api: public
# txt: Retrieves the path of the script.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the path of the script.
# use: DW.getScriptPath; echo "Script path: ${RESULT}";
function DW.getScriptPath() {
  DW.getGlobalStringValue DRYWIT SCRIPT_PATH;
}

# fun: DW.getScriptFolder
# api: public
# txt: Retrieves the folder of the script.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the folder of the script.
# use: DW.getScriptFolder; echo "Script folder: ${RESULT}";
function DW.getScriptFolder() {
  DW.getGlobalStringValue DRYWIT SCRIPT_FOLDER;
}

# env: __DRYWIT_BOOTSTRAP_MODULES: The modules included in the bootstrap process.
declare -agx __DRYWIT_BOOTSTRAP_MODULES=(\
   "stdlib" \
   "string" \
   "color" \
   "array" \
   "check" \
   "envvar" \
   "constant" \
   "error" \
   "term" \
   "echo" \
   "logging" \
   "cli" \
   "dw-plumbing" \
   "file" \
   "debug" \
   "package"
);

# env: __DRYWIT_IMPORTED_MODULES: The modules eventually imported in the bootstrap process.
declare -agx __DRYWIT_IMPORTED_MODULES=();

# env: DRYWIT_MODULE_TAG: The dry-wit git tag used to download modules from github.
export DRYWIT_MODULE_TAG="master";

# env: DRYWIT_MODULE_URL: The url to download dry-wit modules.
export DRYWIT_MODULE_URL="https://raw.githubusercontent.com/rydnr/dry-wit/${DRYWIT_MODULE_TAG}/src/modules";

# env: DRYWIT_MODULE_PATH: Where to download dry-wit modules.
export DRYWIT_MODULE_PATH="${HOME:-/root}/.dry-wit/src/modules"

# fun: BOOTSTRAP.failsafeExitWithError
# api: private
# txt: A fail-safe version of exitWithError.
# opt: label: The error label.
# opt: message: The error message.
# use: BOOTSTRAP.failsafeExitWithError UNACCEPTABLE_API_CALL "'name' cannot be empty";
function BOOTSTRAP.failsafeExitWithError() {
  local _label="${1}";
  local _message="${2}";

  if BOOTSTRAP.failsafeIsFunctionDefined "exitWithError"; then
    exitWithError "${_label}" "${_message}";
  else
    echo "${_message}";
    exit 1;
  fi
}

# fun: checkNotEmpty
# api: public
# txt: A fail-safe version of checkNotEmpty.
# opt: name: The parameter name.
# opt: value: The parameter value.
# opt: index: The parameter index.
# txt: Exits if the parameter value is empty.
# use: checkNotEmpty module "${module}" 1
function checkNotEmpty() {
  BOOTSTRAP.failsafeCheckNotEmpty $@;
}

# fun: BOOTSTRAP.failsafeCheckNotEmpty
# api: private
# txt: A fail-safe version of checkNotEmpty.
# opt: name: The parameter name.
# opt: value: The parameter value.
# opt: index: The parameter index.
# txt: Exits if the parameter value is empty.
# use: BOOTSTRAP.failsafeCheckNotEmpty module "${module}" 1
function BOOTSTRAP.failsafeCheckNotEmpty() {
  local _name="${1}";
  if [ -z "${_name}" ]; then
    BOOTSTRAP.failsafeExitWithError UNACCEPTABLE_API_CALL "'name' (1) cannot be empty when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  local _value="${2}";

  if [ -z "${_value}" ]; then
    BOOTSTRAP.failsafeExitWithError UNACCEPTABLE_API_CALL "'${_name}' (${_value}) cannot be empty when calling ${FUNCNAME[1]}. Review ${FUNCNAME[2]}";
  fi

  local _index="${3}";
  if [ -z "${_index}" ]; then
    BOOTSTRAP.failsafeExitWithError UNACCEPTABLE_API_CALL "'index' (3) cannot be empty when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
}

# fun: BOOTSTRAP.failsafeIsEmpty
# api: private
# txt: A fail-safe version of isEmpty.
# opt: name: The parameter name.
# txt: Returns 0/TRUE if the value is empty; 1/FALSE otherwise.
# use: BOOTSTRAP.failsafeIsEmpty "${value}";
function BOOTSTRAP.failsafeIsEmpty() {
  local _name="${1}";
  local -i _rescode;

  if [ -z "${_name}" ]; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# fun: BOOTSTRAP.failsafeIsDebugEnabled
# api: private
# txt: A fail-safe version of isDebugEnabled.
# txt: Returns 0/TRUE if DEBUG logging is enabled; 1/FALSE otherwise.
# use: if BOOTSTRAP.failsafeIsDebugEnabled; then ...; fi
function BOOTSTRAP.failsafeIsDebugEnabled() {
  local -i _rescode=${FALSE};
  local _oldIFS="${IFS}";

  if BOOTSTRAP.failsafeIsFunctionDefined "isDebugEnabled"; then
    isDebugEnabled;
    _rescode=$?;
  else
    IFS="${DWIFS}";
    for _flag in ${BASH_ARGV[@]}; do
      IFS="${_oldIFS}";
      if [ "${_flag}" == "-v" ]; then
	        _rescode=${TRUE};
	        break;
      fi
    done
    IFS="${_oldIFS}";
  fi

  return ${_rescode};
}

# fun: BOOTSTRAP.failsafeIsTraceEnabled
# api: private
# txt: A fail-safe version of isTraceEnabled.
# txt: Returns 0/TRUE if TRACE logging is enabled; 1/FALSE otherwise.
# use: if BOOTSTRAP.failsafeIsTraceEnabled; then ...; fi
function BOOTSTRAP.failsafeIsTraceEnabled() {
    local -i _rescode=${FALSE};
    local _oldIFS="${IFS}";

    if BOOTSTRAP.failsafeIsFunctionDefined "isTraceEnabled"; then
        isTraceEnabled;
        _rescode=$?;
    else
        IFS="${DWIFS}";
        for _flag in ${BASH_ARGV[@]}; do
            IFS="${_oldIFS}";
            if [ "${_flag}" == "-vv" ]; then
	              _rescode=${TRUE};
	              break;
            fi
        done
        IFS="${_oldIFS}";
    fi

    return ${_rescode};
}

# fun: BOOTSTRAP.failsafeLogDebug
# api: private
# txt: A fail-safe version of logDebug.
# opt: -n: Whether to omit a newline. Optional.
# opt: message: The message.
# use: BOOTSTRAP.failsafeLogDebug "Processing file ${file}";
function BOOTSTRAP.failsafeLogDebug() {
  local _message="${1}";
  local -i _newline=0;
  local -i _position=1;

  if [ "${_message}" == "-n" ]; then
    _newline=1;
    _message="${2}";
    _position=2;
  fi

  BOOTSTRAP.failsafeCheckNotEmpty "message" "${_message}" ${_position};

  ## Needed since this function is used in bootstrapping, and could be loaded before
  ## logTrace is loaded.
  if BOOTSTRAP.failsafeIsFunctionDefined "logDebug"; then
    logDebug $@;
  elif BOOTSTRAP.failsafeIsDebugEnabled; then
    if [ ${_newline} -eq 0 ]; then
      command echo "[dry-wit:bootstrap] ${_message}";
    else
      command echo "[dry-wit:bootstrap] ${_message} ... ";
    fi
  fi
}

# fun: BOOTSTRAP.failsafeLogTrace
# api: private
# txt: A fail-safe version of logTrace.
# opt: -n: Whether to omit a newline. Optional.
# opt: message: The message.
# use: BOOTSTRAP.failsafeLogTrace "Processing file ${file}";
function BOOTSTRAP.failsafeLogTrace() {
    local _message="${1}";
    local -i _newline=0;
    local -i _position=1;

    if [ "${_message}" == "-n" ]; then
        _newline=1;
        _message="${2}";
        _position=2;
    fi

    BOOTSTRAP.failsafeCheckNotEmpty "message" "${_message}" ${_position};

    ## Needed since this function is used in bootstrapping, and could be loaded before
    ## logTrace is loaded.
    if BOOTSTRAP.failsafeIsFunctionDefined "logTrace"; then
        logTrace $@;
    elif BOOTSTRAP.failsafeIsTraceEnabled; then
        if [ ${_newline} -eq 0 ]; then
            command echo "[dry-wit:bootstrap] ${_message}";
        else
            command echo "[dry-wit:bootstrap] ${_message} ... ";
        fi
    fi
}

# fun: BOOTSTRAP.failsafeLogDebugResult.
# api: private
# txt: A fail-safe version of logDebugResult.
# opt: outcome: The outcome.
# opt: message: The message.
# use: BOOTSTRAP.failsafeLogDebugResult SUCCESS "done"
function BOOTSTRAP.failsafeLogDebugResult() {
  local _outcome="${1}";
  local _outcomeMessage="${2}";

  BOOTSTRAP.failsafeCheckNotEmpty "outcome" "${_outcome}" 1;
  BOOTSTRAP.failsafeCheckNotEmpty "outcomeMessage" "${_outcomeMessage}" 2;

  ## Needed since this function is used in bootstrapping, and could be loaded before
  ## logTraceResult is loaded.
  if BOOTSTRAP.failsafeIsFunctionDefined "logDebugResult"; then
    logDebugResult ${_outcome} "${_outcomeMessage}";
  fi
}

# fun: BOOTSTRAP.failsafeLogTraceResult.
# api: private
# txt: A fail-safe version of logTraceResult.
# opt: outcome: The outcome.
# opt: message: The message.
# use: BOOTSTRAP.failsafeLogTraceResult SUCCESS "done"
function BOOTSTRAP.failsafeLogTraceResult() {
    local _outcome="${1}";
    local _outcomeMessage="${2}";

    BOOTSTRAP.failsafeCheckNotEmpty "outcome" "${_outcome}" 1;
    BOOTSTRAP.failsafeCheckNotEmpty "outcomeMessage" "${_outcomeMessage}" 2;

    ## Needed since this function is used in bootstrapping, and could be loaded before
    ## logTraceResult is loaded.
    if BOOTSTRAP.failsafeIsFunctionDefined "logTraceResult"; then
        logTraceResult ${_outcome} "${_outcomeMessage}";
    fi
}

# fun: BOOTSTRAP.failsafeIsFunctionDefined
# api: private
# txt: A fail-safe version of isFunctionDefined.
# opt: name: The function name.
# txt: Returns 0/TRUE if the function is defined; 1/FALSE otherwise.
# use: if BOOTSTRAP.failsafeIsFunctionDefined "readFile"; then echo "readFile defined"; fi
function BOOTSTRAP.failsafeIsFunctionDefined() {
  local _function="${1}";
  local -i _rescode;

  BOOTSTRAP.failsafeCheckNotEmpty "function" "${_function}" 1;

  type "${_function}" 2> /dev/null | grep -q 'function';
  _rescode=$?;

  return ${_rescode};
}

# fun: BOOTSTRAP.failsafeArrayContains
# api: private
# txt: A fail-safe version of arrayContains.
# opt: array: The array (passed as "${array[@]}".
# opt: element: The element to check.
# txt: Returns 0/TRUE: If the element is present in the array; 1/FALSE otherwise.
# use: a=("one" "two" "three" "other number"); if BOOTSTRAP.failsafeArrayContains "${a[@]}" "other number"; then ...; fi
function BOOTSTRAP.failsafeArrayContains() {
  local _item="${1}";
  local _array="${2}";
  local _aux;
  local -i _rescode=${FALSE};
  local _oldIFS="${IFS}";

  BOOTSTRAP.failsafeCheckNotEmpty "item" "${_item}" 1;

  IFS="${DWIFS}";
  for _aux in ${_array}; do
    IFS="${_oldIFS}";
    if [[ "${_aux}" == "${_item}" ]]; then
      _rescode=${TRUE};
      break;
    fi
  done
  IFS="${_oldIFS}";

  return ${_rescode};
}

# fun: BOOTSTRAP.toUpper
# api: public
# txt: Converts given string to upper case.
# opt: text: The string to convert.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the string in upper case.
# use: local _text="abc"; toUpper "${_text}"; local _upcased="${RESULT}";
function BOOTSTRAP.toUpper() {
  local _text="${1}";
  BOOTSTRAP.failsafeCheckNotEmpty "text" "${_text}" 1;

  local result=$(echo "${_text}" | awk '{print toupper($0);}');
  export RESULT="${result}";
}

# fun: downloadModule
# api: public
# txt: Downloads given module.
# opt: name: The module name.
# txt: Returns 0/TRUE if the module is downloaded; 1/FALSE otherwise.
# use:  if downloadModule "fibonacci"; then echo "fibonacci module downloaded"; fi
function downloadModule() {
  local _module="${1}";
  local -i _rescode;
  local _result="";

  BOOTSTRAP.failsafeCheckNotEmpty "module" "${_module}" 1;

  mkdir -p "${DRYWIT_MODULE_PATH}";

  BOOTSTRAP.failsafeLogDebug -n "Downloading ${DRYWIT_MODULE_URL}/${_module}.dw to ${DRYWIT_MODULE_PATH}/${_module}.dw";
  curl -s "${DRYWIT_MODULE_URL}/${_module}.dw" > "${DRYWIT_MODULE_PATH}/${_module}.dw";
  _rescode=$?;
  if [[ ${_rescode} -eq ${TRUE} ]]; then
    BOOTSTRAP.failsafeLogDebugResult SUCCESS "done";
    export RESULT="${DRYWIT_MODULE_PATH}/${_module}.dw";
  else
    rm -f "${DRYWIT_MODULE_PATH}/${_module}.dw";
    curl -s "${DRYWIT_MODULE_URL}/ext/${_module}.dw" > "${DRYWIT_MODULE_PATH}/ext/${_module}.dw";
    _rescode=$?;
  fi

  if [[ ${_rescode} -eq ${TRUE} ]]; then
    BOOTSTRAP.failsafeLogDebugResult SUCCESS "done";
    export RESULT="${DRYWIT_MODULE_PATH}/ext/${_module}.dw";
  else
    rm -f "${DRYWIT_MODULE_PATH}/ext/${_module}.dw";
    BOOTSTRAP.failsafeLogDebugResult FAILURE "failed";
  fi

  return ${_rescode};
}

# fun: BOOTSTRAP.bootstrap
# txt: Bootstraps dry-wit.
# txt: Returns always 0/TRUE.
# use: BOOTSTRAP.bootstrap;
function BOOTSTRAP.bootstrap() {
  local _module;
  local _modulePath;
  local _oldIFS="${IFS}";
  IFS="${_oldIFS}";

  IFS=${DWIFS};
  for _module in ${__DRYWIT_BOOTSTRAP_MODULES[*]}; do
    IFS="${_oldIFS}";
    DW.import "${_module}";
  done
  IFS="${_oldIFS}";
}

# fun: DW.import
# api: public
# txt: Imports given module.
# opt: module: The module to import.
# txt: Returns 0/TRUE always. If the module cannot be imported, exits.
# use: DW.import logging;
function DW.import() {
  local _module="${1}";

  ## Needed since this function is used in bootstrapping, and could be loaded before
  ## checkNotEmpty is loaded.
  BOOTSTRAP.failsafeCheckNotEmpty "module" "${_module}" 1;

  if findModule "${_module}"; then
    _modulePath="${RESULT}";
  elif downloadModule "${_module}"; then
    _modulePath="${RESULT}";
  else
    echo "ERROR: Required module ${_module}.dw not found. Is it correctly spelled?"
    exit 1;
  fi

  if ! BOOTSTRAP.failsafeArrayContains "${_module}" "${__DRYWIT_IMPORTED_MODULES[@]}"; then
    BOOTSTRAP.failsafeLogTrace -n "Loading ${_modulePath}";
    source "${_modulePath}";
    BOOTSTRAP.failsafeLogTraceResult SUCCESS "done";

    BOOTSTRAP.toUpper "${_module}";
    local _upcasedModule="${RESULT}";
    if BOOTSTRAP.failsafeIsFunctionDefined "${_upcasedModule}.resetState"; then
      BOOTSTRAP.failsafeLogTrace -n "Resetting ${_module} state";
      ${_upcasedModule}.resetState;
      BOOTSTRAP.failsafeLogTraceResult SUCCESS "done";
    fi

    __DRYWIT_IMPORTED_MODULES[${#__DRYWIT_IMPORTED_MODULES[@]}]="${_module}";
  fi
}

# fun: findModule
# api: public
# txt: Finds given module locally.
# opt: module: The name of the module.
# txt: Returns 0/TRUE if the module is found; 1/FALSE otherwise.
# use: if findModule "fibonacci"; then DW.import fibonacci; fi
function findModule() {
  local _module="${1}";
  local -i _rescode=${FALSE};

  if [[ -e "${DRYWIT_MODULE_PATH}/${_module}.dw" ]]; then
    _rescode=${TRUE};
    export RESULT="${DRYWIT_MODULE_PATH}/${_module}.dw";
  elif [[ -e "${DRYWIT_MODULE_PATH}/ext/${_module}.dw" ]]; then
     _rescode=${TRUE};
      export RESULT="${DRYWIT_MODULE_PATH}/ext/${_module}.dw";
  fi

  return ${_rescode};
}

# fun: BOOTSTRAP.endsWith
# api: private
# txt: Checks whether the first parameter ends with the second value.
# opt: text: The text.
# opt: substring: The substring to check.
# txt: Returns 0/TRUE if the text ends with the substring; 1/FALSE otherwise.
# use: if BOOTSTRAP.endsWith "${text}" "c"; then echo "${text} ends with c"; fi
function BOOTSTRAP.endsWith() {
  local _container="${1}";
  local _substring="${2}";
  local -i _rescode;

  BOOTSTRAP.failsafeCheckNotEmpty "container" "${_container}" 1;
  BOOTSTRAP.failsafeCheckNotEmpty "substring" "${_substring}" 2;

  if [[ "${_container%${_substring}}" == "${_container}" ]]; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

# env: TRUE: A synomim for 0.
declare -igx TRUE=0;

# env: FALSE: A synomim for 1.
declare -igx FALSE=1;

# env: DWIFS: The IFS used by dry-wit.
declare -gx DWIFS=$' \t\n';

# fun: DW.init
# api: private
# txt: Initializes dry-wit.
# use: DW.init
function DW.init() {

  if [ -z ${SCRIPT_INDEX+x} ]; then
    declare -igx SCRIPT_INDEX=0;
  else
    if DW.nested; then
      SCRIPT_INDEX=$((SCRIPT_INDEX+1));
    fi
  fi

  local _scriptName;
  local _scriptPath;
  local _scriptFolder;
  if [ "$1" == "" ]; then
    _scriptName="${0}";
    _scriptPath="${0}";
    _scriptFolder="$(dirname "${0}")";
  else
    _scriptName="${1}";
    _scriptPath="${1}";
    _scriptFolder="$(dirname "${1}")";
    shift;
  fi
  if [ "${_scriptFolder}" == "." ]; then
    _scriptFolder="${PWD}";
  fi
  DW.declareGlobalString DRYWIT SCRIPT_NAME "${_scriptName}";
  DW.declareGlobalString DRYWIT SCRIPT_PATH "${_scriptPath}";
  DW.declareGlobalString DRYWIT SCRIPT_FOLDER "${_scriptFolder}";
}

function DW.isTest() {
  DW.getScriptName;
  local _scriptName="${RESULT}";

  echo "SCRIPT_NAME: ${_scriptName}";
  if    BOOTSTRAP.endsWith "${_scriptName}" "-tests.sh" \
     || BOOTSTRAP.endsWith "${_scriptName}" "-test.sh"; then
    source $(which dry-wit-test) "${_scriptName}" $@;
  fi
}

BOOTSTRAP.bootstrap;
DW.init $@;
DW.isTest $@;
DRYWIT.main $@;

cleanup;
#
